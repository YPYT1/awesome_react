# é”™è¯¯è¾¹ç•Œæœ€ä½³å®è·µ

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¾è®¡åŸåˆ™

### 1.1 ç²’åº¦æ§åˆ¶åŸåˆ™

```javascript
// åŸåˆ™1ï¼šå…³é”®åŠŸèƒ½ç‹¬ç«‹è¾¹ç•Œ
function App() {
  return (
    <div>
      {/* é™æ€å†…å®¹ï¼šæ— éœ€è¾¹ç•Œ */}
      <Header />
      
      {/* å…³é”®åŠŸèƒ½ï¼šç‹¬ç«‹è¾¹ç•Œ */}
      <ErrorBoundary name="payment" fallback={<PaymentError />}>
        <PaymentModule />
      </ErrorBoundary>
      
      {/* ç”¨æˆ·ç”Ÿæˆå†…å®¹ï¼šç‹¬ç«‹è¾¹ç•Œ */}
      <ErrorBoundary name="content" fallback={<ContentError />}>
        <UserContent />
      </ErrorBoundary>
      
      {/* ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼šç‹¬ç«‹è¾¹ç•Œ */}
      <ErrorBoundary name="chat" fallback={<ChatError />}>
        <ThirdPartyChat />
      </ErrorBoundary>
      
      {/* é™æ€å†…å®¹ï¼šæ— éœ€è¾¹ç•Œ */}
      <Footer />
    </div>
  );
}

// åŸåˆ™2ï¼šé¿å…è¿‡åº¦åµŒå¥—
// âŒ è¿‡åº¦åµŒå¥—
function OverNested() {
  return (
    <ErrorBoundary>
      <ErrorBoundary>
        <ErrorBoundary>
          <Content />
        </ErrorBoundary>
      </ErrorBoundary>
    </ErrorBoundary>
  );
}

// âœ… åˆç†åµŒå¥—
function ReasonableNesting() {
  return (
    <ErrorBoundary name="app" fallback={<AppError />}>
      <Page />
    </ErrorBoundary>
  );
}

function Page() {
  return (
    <div>
      <Header />
      
      <ErrorBoundary name="content" fallback={<ContentError />}>
        <MainContent />
      </ErrorBoundary>
    </div>
  );
}
```

### 1.2 ç”¨æˆ·ä½“éªŒåŸåˆ™

```javascript
// åŸåˆ™3ï¼šæä¾›æœ‰æ„ä¹‰çš„fallback
// âŒ æ— ç”¨çš„é”™è¯¯æç¤º
<ErrorBoundary fallback={<div>Error</div>}>
  <Component />
</ErrorBoundary>

// âœ… æœ‰æ„ä¹‰çš„fallback
<ErrorBoundary 
  fallback={
    <div className="error-fallback">
      <Icon name="warning" />
      <h2>åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨</h2>
      <p>æˆ‘ä»¬æ­£åœ¨ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œè¯·ç¨åå†è¯•</p>
      <button onClick={() => window.location.reload()}>
        åˆ·æ–°é¡µé¢
      </button>
    </div>
  }
>
  <Component />
</ErrorBoundary>

// åŸåˆ™4ï¼šä¿ç•™å°½å¯èƒ½å¤šçš„åŠŸèƒ½
function PreserveFunction() {
  return (
    <div className="dashboard">
      {/* å¯¼èˆªå§‹ç»ˆå¯ç”¨ */}
      <Navigation />
      
      {/* ä¸»åŠŸèƒ½ç‹¬ç«‹ä¿æŠ¤ */}
      <ErrorBoundary fallback={<WidgetError />}>
        <StatisticsWidget />
      </ErrorBoundary>
      
      <ErrorBoundary fallback={<ChartError />}>
        <ChartWidget />
      </ErrorBoundary>
      
      {/* æ¬¡è¦åŠŸèƒ½ç‹¬ç«‹ä¿æŠ¤ */}
      <ErrorBoundary fallback={null}>
        <RecommendationWidget />
      </ErrorBoundary>
    </div>
  );
}

// åŸåˆ™5ï¼šæä¾›æ¢å¤æœºåˆ¶
class RecoverableErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="recoverable-error">
          <h3>å‡ºé”™äº†</h3>
          <div className="actions">
            <button onClick={() => this.setState({ hasError: false })}>
              é‡è¯•
            </button>
            <button onClick={() => window.location.reload()}>
              åˆ·æ–°é¡µé¢
            </button>
            <button onClick={() => window.history.back()}>
              è¿”å›ä¸Šä¸€é¡µ
            </button>
          </div>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

### 1.3 é”™è¯¯ç›‘æ§åŸåˆ™

```javascript
// åŸåˆ™6ï¼šå®Œæ•´çš„é”™è¯¯ä¸Šä¸‹æ–‡
class ContextualErrorBoundary extends React.Component {
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    const context = {
      // é”™è¯¯è¯¦æƒ…
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      },
      
      // ç»„ä»¶ä¿¡æ¯
      component: {
        name: this.constructor.name,
        props: this.props,
        state: this.state,
        stack: errorInfo.componentStack
      },
      
      // ç¯å¢ƒä¿¡æ¯
      environment: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString(),
        nodeEnv: process.env.NODE_ENV
      },
      
      // ç”¨æˆ·ä¿¡æ¯
      user: {
        id: this.props.userId,
        session: sessionStorage.getItem('sessionId')
      }
    };
    
    this.reportError(context);
  }
  
  reportError(context) {
    // å‘é€åˆ°ç›‘æ§æœåŠ¡
  }
}

// åŸåˆ™7ï¼šåŒºåˆ†é”™è¯¯ä¸¥é‡ç¨‹åº¦
function ErrorSeverity() {
  return (
    <div>
      {/* è‡´å‘½é”™è¯¯ï¼šé˜»æ­¢ä½¿ç”¨ */}
      <ErrorBoundary 
        severity="critical"
        fallback={<CriticalErrorPage />}
      >
        <PaymentProcessor />
      </ErrorBoundary>
      
      {/* é‡è¦é”™è¯¯ï¼šé™çº§åŠŸèƒ½ */}
      <ErrorBoundary 
        severity="high"
        fallback={<DegradedFeature />}
      >
        <MainFeature />
      </ErrorBoundary>
      
      {/* ä¸€èˆ¬é”™è¯¯ï¼šé™é»˜å¤„ç† */}
      <ErrorBoundary 
        severity="low"
        fallback={null}
        onError={logError}
      >
        <NonCriticalWidget />
      </ErrorBoundary>
    </div>
  );
}
```

## ç¬¬äºŒéƒ¨åˆ†ï¼šå®ç°æ¨¡å¼

### 2.1 é€šç”¨é”™è¯¯è¾¹ç•Œ

```javascript
// å¯å¤ç”¨çš„é€šç”¨é”™è¯¯è¾¹ç•Œ
class UniversalErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    };
  }
  
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error,
      errorId: generateErrorId()
    };
  }
  
  componentDidCatch(error, errorInfo) {
    const { onError, reportToService } = this.props;
    
    // æ›´æ–°state
    this.setState({ errorInfo });
    
    // è‡ªå®šä¹‰é”™è¯¯å¤„ç†
    if (onError) {
      onError(error, errorInfo);
    }
    
    // ä¸ŠæŠ¥æœåŠ¡
    if (reportToService !== false) {
      this.reportError(error, errorInfo);
    }
  }
  
  reportError(error, errorInfo) {
    const { boundaryName, userId } = this.props;
    
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        errorId: this.state.errorId,
        boundaryName,
        userId,
        error: {
          message: error.message,
          stack: error.stack
        },
        errorInfo: {
          componentStack: errorInfo.componentStack
        },
        timestamp: Date.now()
      })
    });
  }
  
  reset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    });
  };
  
  render() {
    const { hasError, error, errorInfo, errorId } = this.state;
    const { fallback, FallbackComponent, children } = this.props;
    
    if (hasError) {
      // è‡ªå®šä¹‰FallbackComponent
      if (FallbackComponent) {
        return (
          <FallbackComponent
            error={error}
            errorInfo={errorInfo}
            errorId={errorId}
            reset={this.reset}
          />
        );
      }
      
      // ç®€å•fallback
      if (fallback) {
        return fallback;
      }
      
      // é»˜è®¤fallback
      return (
        <div className="default-error-fallback">
          <h2>å‡ºé”™äº†</h2>
          <p>é”™è¯¯ID: {errorId}</p>
          <button onClick={this.reset}>é‡è¯•</button>
        </div>
      );
    }
    
    return children;
  }
}

function generateErrorId() {
  return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// ä½¿ç”¨ç¤ºä¾‹
function App() {
  return (
    <UniversalErrorBoundary
      boundaryName="main-app"
      userId={currentUser.id}
      FallbackComponent={CustomErrorPage}
      onError={(error, errorInfo) => {
        console.error('App error:', error);
      }}
    >
      <MainApp />
    </UniversalErrorBoundary>
  );
}
```

### 2.2 è·¯ç”±çº§é”™è¯¯è¾¹ç•Œ

```javascript
// è·¯ç”±ä¸“ç”¨é”™è¯¯è¾¹ç•Œ
function AppRouter() {
  return (
    <BrowserRouter>
      <Routes>
        <Route
          path="/"
          element={
            <RouteErrorBoundary>
              <Home />
            </RouteErrorBoundary>
          }
        />
        
        <Route
          path="/dashboard"
          element={
            <RouteErrorBoundary>
              <Dashboard />
            </RouteErrorBoundary>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}

class RouteErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    const currentRoute = window.location.pathname;
    
    logError({
      error,
      errorInfo,
      route: currentRoute,
      referrer: document.referrer
    });
  }
  
  componentDidUpdate(prevProps) {
    // è·¯ç”±å˜åŒ–æ—¶é‡ç½®é”™è¯¯
    if (this.props.location !== prevProps.location) {
      this.setState({ hasError: false });
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="route-error">
          <h1>é¡µé¢åŠ è½½å¤±è´¥</h1>
          <button onClick={() => window.history.back()}>
            è¿”å›ä¸Šä¸€é¡µ
          </button>
          <button onClick={() => window.location.href = '/'}>
            è¿”å›é¦–é¡µ
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// é«˜é˜¶ç»„ä»¶åŒ…è£…
function withErrorBoundary(Component, errorBoundaryProps) {
  return function WithErrorBoundaryComponent(props) {
    return (
      <ErrorBoundary {...errorBoundaryProps}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}

// ä½¿ç”¨
const SafeProfile = withErrorBoundary(UserProfile, {
  fallback: <ProfileError />,
  onError: logProfileError
});
```

### 2.3 å¼‚æ­¥è¾¹ç•Œæ¨¡å¼

```javascript
// å¤„ç†å¼‚æ­¥åŠ è½½é”™è¯¯
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => 
  import('./Component').catch(error => {
    // æ•è·chunkåŠ è½½é”™è¯¯
    console.error('Chunk load error:', error);
    return { default: () => <ChunkLoadError /> };
  })
);

function AsyncErrorBoundary({ children }) {
  return (
    <ErrorBoundary
      fallback={<AsyncError />}
      onError={(error) => {
        if (error.name === 'ChunkLoadError') {
          // ç‰¹æ®Šå¤„ç†chunkåŠ è½½é”™è¯¯
          window.location.reload();
        }
      }}
    >
      <Suspense fallback={<Loading />}>
        {children}
      </Suspense>
    </ErrorBoundary>
  );
}

// ä½¿ç”¨
function App() {
  return (
    <AsyncErrorBoundary>
      <LazyComponent />
    </AsyncErrorBoundary>
  );
}
```

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šé”™è¯¯å¤„ç†ç­–ç•¥

### 3.1 åˆ†å±‚é”™è¯¯å¤„ç†

```javascript
// ä¸‰å±‚é”™è¯¯å¤„ç†æ¶æ„
function LayeredErrorHandling() {
  return (
    // ç¬¬ä¸€å±‚ï¼šåº”ç”¨çº§
    <AppErrorBoundary>
      <App />
    </AppErrorBoundary>
  );
}

function App() {
  return (
    <div>
      <GlobalHeader />
      
      {/* ç¬¬äºŒå±‚ï¼šé¡µé¢çº§ */}
      <PageErrorBoundary>
        <CurrentPage />
      </PageErrorBoundary>
      
      <GlobalFooter />
    </div>
  );
}

function CurrentPage() {
  return (
    <div>
      <PageHeader />
      
      {/* ç¬¬ä¸‰å±‚ï¼šç»„ä»¶çº§ */}
      <ComponentErrorBoundary>
        <ComplexWidget />
      </ComponentErrorBoundary>
      
      <ComponentErrorBoundary>
        <AnotherWidget />
      </ComponentErrorBoundary>
    </div>
  );
}

// æ¯å±‚æœ‰ä¸åŒçš„å¤„ç†ç­–ç•¥
class AppErrorBoundary extends React.Component {
  // åº”ç”¨çº§ï¼šè®°å½•ã€æŠ¥è­¦ã€æ˜¾ç¤ºå…¨å±€é”™è¯¯é¡µ
}

class PageErrorBoundary extends React.Component {
  // é¡µé¢çº§ï¼šè®°å½•ã€éƒ¨åˆ†é™çº§
}

class ComponentErrorBoundary extends React.Component {
  // ç»„ä»¶çº§ï¼šè®°å½•ã€éšè—ç»„ä»¶æˆ–æ˜¾ç¤ºå ä½ç¬¦
}
```

### 3.2 é”™è¯¯é™çº§ç­–ç•¥

```javascript
// æ¸è¿›å¼é™çº§
class GracefulDegradationBoundary extends React.Component {
  state = { 
    hasError: false, 
    degradationLevel: 0 
  };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    const newLevel = this.state.degradationLevel + 1;
    this.setState({ degradationLevel: newLevel });
    
    logError(error, errorInfo, { degradationLevel: newLevel });
  }
  
  render() {
    const { degradationLevel } = this.state;
    
    // æ­£å¸¸æ¨¡å¼
    if (degradationLevel === 0) {
      return <FullFeatureComponent />;
    }
    
    // ç¬¬ä¸€çº§é™çº§ï¼šç®€åŒ–åŠŸèƒ½
    if (degradationLevel === 1) {
      return <SimplifiedComponent />;
    }
    
    // ç¬¬äºŒçº§é™çº§ï¼šåŸºç¡€åŠŸèƒ½
    if (degradationLevel === 2) {
      return <BasicComponent />;
    }
    
    // å®Œå…¨é™çº§ï¼šé™æ€å†…å®¹
    return <StaticFallback />;
  }
}
```

### 3.3 é”™è¯¯æ¢å¤ç­–ç•¥

```javascript
// æ™ºèƒ½æ¢å¤
class SmartRecoveryBoundary extends React.Component {
  state = {
    hasError: false,
    retryCount: 0,
    lastError: null
  };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, lastError: error };
  }
  
  componentDidCatch(error, errorInfo) {
    this.logError(error, errorInfo);
    
    // è‡ªåŠ¨æ¢å¤é€»è¾‘
    if (this.canAutoRecover(error)) {
      this.scheduleRecovery();
    }
  }
  
  canAutoRecover(error) {
    // å¯æ¢å¤çš„é”™è¯¯ç±»å‹
    const recoverableTypes = [
      'NetworkError',
      'TimeoutError',
      'TemporaryUnavailable'
    ];
    
    return recoverableTypes.some(type => 
      error.name.includes(type)
    ) && this.state.retryCount < 3;
  }
  
  scheduleRecovery() {
    const delay = Math.min(1000 * Math.pow(2, this.state.retryCount), 10000);
    
    setTimeout(() => {
      this.setState(prev => ({
        hasError: false,
        retryCount: prev.retryCount + 1
      }));
    }, delay);
  }
  
  manualRetry = () => {
    this.setState({
      hasError: false,
      retryCount: 0
    });
  };
  
  render() {
    if (this.state.hasError) {
      const { retryCount, lastError } = this.state;
      
      return (
        <div className="error-recovery">
          <h2>å‡ºé”™äº†</h2>
          <p>{lastError?.message}</p>
          
          {retryCount < 3 ? (
            <div>
              <p>æ­£åœ¨å°è¯•æ¢å¤... (ç¬¬ {retryCount + 1} æ¬¡)</p>
              <button onClick={this.manualRetry}>ç«‹å³é‡è¯•</button>
            </div>
          ) : (
            <div>
              <p>æ— æ³•è‡ªåŠ¨æ¢å¤</p>
              <button onClick={() => window.location.reload()}>
                åˆ·æ–°é¡µé¢
              </button>
            </div>
          )}
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

## ç¬¬å››éƒ¨åˆ†ï¼šæµ‹è¯•ä¸è°ƒè¯•

### 4.1 é”™è¯¯è¾¹ç•Œæµ‹è¯•

```javascript
// æµ‹è¯•å·¥å…·
import { render, screen } from '@testing-library/react';

describe('ErrorBoundary', () => {
  beforeEach(() => {
    // æŠ‘åˆ¶Reacté”™è¯¯æ—¥å¿—
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });
  
  afterEach(() => {
    console.error.mockRestore();
  });
  
  it('should render fallback on error', () => {
    const ThrowError = () => {
      throw new Error('Test error');
    };
    
    render(
      <ErrorBoundary fallback={<div>Error occurred</div>}>
        <ThrowError />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Error occurred')).toBeInTheDocument();
  });
  
  it('should call onError callback', () => {
    const onError = jest.fn();
    const ThrowError = () => {
      throw new Error('Test error');
    };
    
    render(
      <ErrorBoundary onError={onError}>
        <ThrowError />
      </ErrorBoundary>
    );
    
    expect(onError).toHaveBeenCalled();
    expect(onError.mock.calls[0][0].message).toBe('Test error');
  });
  
  it('should reset error on retry', () => {
    const ThrowError = ({ shouldThrow }) => {
      if (shouldThrow) {
        throw new Error('Test error');
      }
      return <div>Success</div>;
    };
    
    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText(/error/i)).toBeInTheDocument();
    
    // æ¨¡æ‹Ÿé‡ç½®
    rerender(
      <ErrorBoundary key="new">
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Success')).toBeInTheDocument();
  });
});

// E2Eæµ‹è¯•
describe('ErrorBoundary E2E', () => {
  it('should handle production errors', async () => {
    await page.goto('http://localhost:3000');
    
    // è§¦å‘é”™è¯¯
    await page.click('#buggy-button');
    
    // éªŒè¯é”™è¯¯UI
    const errorMessage = await page.$eval(
      '.error-fallback',
      el => el.textContent
    );
    
    expect(errorMessage).toContain('å‡ºé”™äº†');
    
    // éªŒè¯é”™è¯¯ä¸ŠæŠ¥
    const errorRequests = await page.evaluate(() => {
      return window.errorLog;
    });
    
    expect(errorRequests.length).toBeGreaterThan(0);
  });
});
```

### 4.2 è°ƒè¯•æŠ€å·§

```javascript
// å¼€å‘ç¯å¢ƒè°ƒè¯•
class DebugErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    if (process.env.NODE_ENV === 'development') {
      // è¯¦ç»†çš„æ§åˆ¶å°è¾“å‡º
      console.group('ğŸš¨ Error Boundary Caught Error');
      console.error('Error:', error);
      console.error('Component Stack:', errorInfo.componentStack);
      console.error('Props:', this.props);
      console.error('State:', this.state);
      console.groupEnd();
      
      // è°ƒè¯•æ–­ç‚¹
      debugger;
    }
    
    // ç”Ÿäº§ç¯å¢ƒä¸ŠæŠ¥
    if (process.env.NODE_ENV === 'production') {
      this.reportError(error, errorInfo);
    }
  }
  
  render() {
    if (this.state.hasError) {
      if (process.env.NODE_ENV === 'development') {
        return (
          <div className="dev-error-display">
            <h2>Development Error</h2>
            <pre>{this.state.error.stack}</pre>
          </div>
        );
      }
      
      return <ProductionErrorPage />;
    }
    
    return this.props.children;
  }
}

// é”™è¯¯é‡ç°
class ReplayableErrorBoundary extends React.Component {
  actionsLog = [];
  
  componentDidMount() {
    // è®°å½•æ‰€æœ‰ç”¨æˆ·æ“ä½œ
    window.addEventListener('click', this.logAction);
    window.addEventListener('input', this.logAction);
  }
  
  logAction = (e) => {
    this.actionsLog.push({
      type: e.type,
      target: e.target.tagName,
      timestamp: Date.now()
    });
  };
  
  componentDidCatch(error, errorInfo) {
    // ä¿å­˜é‡ç°æ­¥éª¤
    localStorage.setItem('errorReplay', JSON.stringify({
      error: error.toString(),
      actions: this.actionsLog,
      state: captureAppState()
    }));
  }
  
  componentWillUnmount() {
    window.removeEventListener('click', this.logAction);
    window.removeEventListener('input', this.logAction);
  }
}
```

## æ³¨æ„äº‹é¡¹

### 1. æ€§èƒ½è€ƒè™‘

```javascript
// âœ… é¿å…è¿‡å¤šè¾¹ç•Œ
function Optimized() {
  return (
    <ErrorBoundary>
      <ComponentGroup />  {/* å¤šä¸ªç»„ä»¶å…±äº«ä¸€ä¸ªè¾¹ç•Œ */}
    </ErrorBoundary>
  );
}

function ComponentGroup() {
  return (
    <>
      <Component1 />
      <Component2 />
      <Component3 />
    </>
  );
}

// âŒ è¿‡å¤šç‹¬ç«‹è¾¹ç•Œ
function NotOptimized() {
  return (
    <>
      <ErrorBoundary><Component1 /></ErrorBoundary>
      <ErrorBoundary><Component2 /></ErrorBoundary>
      <ErrorBoundary><Component3 /></ErrorBoundary>
    </>
  );
}
```

### 2. å®‰å…¨è€ƒè™‘

```javascript
// è¿‡æ»¤æ•æ„Ÿä¿¡æ¯
componentDidCatch(error, errorInfo) {
  const sanitizedError = {
    message: error.message.replace(/token=[^&]*/g, 'token=***'),
    stack: error.stack.replace(/password=[^&]*/g, 'password=***')
  };
  
  this.reportError(sanitizedError, errorInfo);
}
```

### 3. ç”¨æˆ·éšç§

```javascript
// éµå®ˆéšç§æ”¿ç­–
componentDidCatch(error, errorInfo) {
  // è·å–ç”¨æˆ·åŒæ„
  if (getUserConsent()) {
    this.reportError(error, errorInfo);
  } else {
    // ä»…æœ¬åœ°è®°å½•
    console.error(error);
  }
}
```

## å¸¸è§é—®é¢˜

### Q1: åº”è¯¥åœ¨å“ªäº›åœ°æ–¹æ·»åŠ é”™è¯¯è¾¹ç•Œï¼Ÿ

**A:** å…³é”®åŠŸèƒ½ã€ç¬¬ä¸‰æ–¹ç»„ä»¶ã€åŠ¨æ€å†…å®¹ã€è·¯ç”±è¾¹ç•Œã€‚

### Q2: é”™è¯¯è¾¹ç•Œä¼šå½±å“æ€§èƒ½å—ï¼Ÿ

**A:** å‡ ä¹æ— å½±å“ï¼Œåªåœ¨é”™è¯¯æ—¶æœ‰å¼€é”€ã€‚

### Q3: å¦‚ä½•æµ‹è¯•é”™è¯¯è¾¹ç•Œï¼Ÿ

**A:** æ‰‹åŠ¨æŠ›å‡ºé”™è¯¯ã€ä½¿ç”¨æµ‹è¯•åº“æ¨¡æ‹Ÿã€‚

### Q4: ç”Ÿäº§å’Œå¼€å‘ç¯å¢ƒåº”è¯¥ä¸åŒå—ï¼Ÿ

**A:** æ˜¯çš„ï¼Œå¼€å‘æ˜¾ç¤ºè¯¦æƒ…ï¼Œç”Ÿäº§å‹å¥½æç¤ºã€‚

### Q5: é”™è¯¯è¾¹ç•Œèƒ½æ•è·æ‰€æœ‰é”™è¯¯å—ï¼Ÿ

**A:** ä¸èƒ½ï¼Œäº‹ä»¶å¤„ç†å™¨å’Œå¼‚æ­¥ä»£ç éœ€å•ç‹¬å¤„ç†ã€‚

### Q6: å¦‚ä½•é¿å…é”™è¯¯è¾¹ç•Œè‡ªèº«å‡ºé”™ï¼Ÿ

**A:** å¤–å±‚åŒ…è£¹å¦ä¸€ä¸ªè¾¹ç•Œï¼Œé˜²å¾¡å¼ç¼–ç¨‹ã€‚

### Q7: åº”è¯¥è®°å½•æ‰€æœ‰é”™è¯¯å—ï¼Ÿ

**A:** æ ¹æ®ä¸¥é‡ç¨‹åº¦ï¼Œä½ä¼˜å…ˆçº§å¯é€‰æ‹©æ€§è®°å½•ã€‚

### Q8: å¦‚ä½•å¤„ç†é¢‘ç¹é”™è¯¯ï¼Ÿ

**A:** å®ç°é™æµã€å»é‡ã€èšåˆæœºåˆ¶ã€‚

### Q9: é”™è¯¯æ¢å¤çš„æœ€ä½³æ—¶æœºï¼Ÿ

**A:** ç”¨æˆ·ä¸»åŠ¨é‡è¯•æˆ–æ£€æµ‹åˆ°æ¡ä»¶æ”¹å–„æ—¶ã€‚

### Q10: å¦‚ä½•å¹³è¡¡ç”¨æˆ·ä½“éªŒå’Œè°ƒè¯•éœ€æ±‚ï¼Ÿ

**A:** å¼€å‘è¯¦ç»†ä¿¡æ¯ï¼Œç”Ÿäº§å‹å¥½æç¤ºåŠ é”™è¯¯IDã€‚

## æ€»ç»“

### æ ¸å¿ƒåŸåˆ™

```
1. è®¾è®¡åŸåˆ™
   âœ… åˆç†ç²’åº¦
   âœ… ç”¨æˆ·ä¼˜å…ˆ
   âœ… åŠŸèƒ½é™çº§
   âœ… æ™ºèƒ½æ¢å¤

2. å®ç°è¦ç‚¹
   âœ… åˆ†å±‚å¤„ç†
   âœ… ç¯å¢ƒåŒºåˆ†
   âœ… å®Œæ•´ä¸Šä¸‹æ–‡
   âœ… å®‰å…¨åˆè§„

3. ç›‘æ§ç­–ç•¥
   âœ… åˆ†çº§ä¸ŠæŠ¥
   âœ… å»é‡èšåˆ
   âœ… è¶‹åŠ¿åˆ†æ
   âœ… åŠæ—¶å‘Šè­¦
```

### å®è·µæ¸…å•

```
âœ… è¯†åˆ«å…³é”®åŠŸèƒ½
âœ… è®¾è®¡è¾¹ç•Œç²’åº¦
âœ… å®ç°é€šç”¨è¾¹ç•Œ
âœ… é…ç½®ç›‘æ§ä¸ŠæŠ¥
âœ… è®¾è®¡fallback UI
âœ… å®ç°æ¢å¤æœºåˆ¶
âœ… ç¼–å†™æµ‹è¯•ç”¨ä¾‹
âœ… åˆ¶å®šå“åº”æµç¨‹
âœ… å®šæœŸå®¡æŸ¥ä¼˜åŒ–
```

é”™è¯¯è¾¹ç•Œæ˜¯Reactåº”ç”¨ç¨³å®šæ€§çš„åŸºçŸ³ï¼Œéµå¾ªæœ€ä½³å®è·µèƒ½æ˜¾è‘—æå‡åº”ç”¨è´¨é‡å’Œç”¨æˆ·æ»¡æ„åº¦ã€‚

