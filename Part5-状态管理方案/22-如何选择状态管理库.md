# 如何选择状态管理库

## 概述

选择合适的状态管理库是React项目成功的关键因素之一。本文提供了系统性的选择框架，帮助开发者根据项目特点、团队情况和业务需求做出明智的技术决策。

## 选择框架

### 决策流程图

```
开始
 ↓
项目规模如何？
 ├─ 小型（<10组件）→ 使用React内置状态
 ├─ 中型（10-50组件）→ 评估业务复杂度
 └─ 大型（50+组件）→ 考虑Redux Toolkit或Jotai
 
中型项目业务复杂度？
 ├─ 简单 → Zustand或Valtio
 ├─ 复杂 → Redux Toolkit或Jotai
 └─ 数据驱动 → React Query + 轻量状态库
```

### 评估维度

```jsx
const evaluationCriteria = {
  // 1. 项目维度
  project: {
    size: '组件数量、页面数量、功能模块数',
    complexity: '业务逻辑复杂度、数据流复杂度',
    lifecycle: '项目生命周期、维护期限',
    performance: '性能要求、用户体验要求'
  },

  // 2. 团队维度
  team: {
    size: '团队人数、协作方式',
    experience: 'React经验、状态管理经验',
    timeline: '开发时间、上线压力',
    preferences: '技术偏好、学习意愿'
  },

  // 3. 技术维度
  technical: {
    ecosystem: '生态系统成熟度',
    typescript: 'TypeScript支持质量',
    devtools: '开发工具完善度',
    testing: '测试友好度'
  },

  // 4. 业务维度
  business: {
    requirements: '功能需求、性能需求',
    timeline: '交付时间要求',
    maintenance: '长期维护需求',
    scalability: '扩展性需求'
  }
};
```

## 详细选择指南

### 小型项目选择

#### 特征
- 组件数量 < 10个
- 简单的数据流
- 开发时间紧张
- 团队规模小

#### 推荐方案

```jsx
// 1. React内置状态 - 最优选择
function SmallApp() {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <UserContext.Provider value={{ user, setUser }}>
        <MainApp />
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

// 优点：
// - 无额外依赖
// - React团队长期支持
// - 学习成本低
// - 适合简单场景

// 2. Valtio - 替代选择
const appState = proxy({
  user: null,
  theme: 'light'
});

function SmallAppWithValtio() {
  const snap = useSnapshot(appState);
  
  return (
    <div className={snap.theme}>
      {snap.user ? (
        <UserProfile user={snap.user} />
      ) : (
        <LoginForm onLogin={(user) => appState.user = user} />
      )}
      <button onClick={() => 
        appState.theme = appState.theme === 'light' ? 'dark' : 'light'
      }>
        Toggle Theme
      </button>
    </div>
  );
}

// 优点：
// - 极其简洁的API
// - 无需Provider
// - 直观的状态修改
// - 自动性能优化
```

#### 不推荐方案

```jsx
// Redux Toolkit - 过度设计
// 问题：
// - 样板代码过多
// - 概念复杂
// - 开发效率低
// - 维护成本高

// Recoil - 风险较高
// 问题：
// - 实验性质，稳定性未知
// - Facebook内部项目，外部支持有限
// - 学习曲线陡峭
// - 社区相对小众
```

### 中型项目选择

#### 特征
- 组件数量 10-50个
- 中等复杂度的业务逻辑
- 需要团队协作
- 有一定的性能要求

#### 推荐方案1：Zustand

```jsx
// 适用场景：平衡简洁性和功能性
const useAppStore = create((set, get) => ({
  // 用户状态
  user: null,
  login: async (credentials) => {
    set({ loading: true });
    const user = await authAPI.login(credentials);
    set({ user, loading: false });
  },
  logout: () => set({ user: null }),

  // UI状态
  theme: 'light',
  sidebarOpen: false,
  setTheme: (theme) => set({ theme }),
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),

  // 数据状态
  data: [],
  fetchData: async () => {
    const data = await dataAPI.getAll();
    set({ data });
  }
}));

// 使用中间件增强功能
const useEnhancedStore = create(
  devtools(
    persist(
      (set) => ({...}),
      { name: 'app-storage' }
    ),
    { name: 'AppStore' }
  )
);

// 优点：
// - API简洁但功能完整
// - 优秀的性能
// - 良好的TypeScript支持
// - 灵活的中间件系统
// - 学习曲线平缓
```

#### 推荐方案2：Jotai

```jsx
// 适用场景：需要细粒度控制或复杂状态依赖
// 用户相关atoms
const userAtom = atom(null);
const isAuthenticatedAtom = atom((get) => !!get(userAtom));

// UI相关atoms
const themeAtom = atom('light');
const sidebarOpenAtom = atom(false);

// 数据相关atoms
const dataAtom = atom([]);
const filteredDataAtom = atom((get) => {
  const data = get(dataAtom);
  const user = get(userAtom);
  // 基于用户权限过滤数据
  return data.filter(item => canUserAccess(user, item));
});

// 优点：
// - 极精确的重渲染控制
// - 灵活的状态组合
// - 优秀的TypeScript支持
// - 适合复杂的状态依赖
```

#### 条件推荐：Redux Toolkit

```jsx
// 当满足以下条件时推荐Redux Toolkit：
const reduxConditions = {
  '团队经验': '团队熟悉Redux概念',
  '项目需求': '需要时间旅行调试',
  '业务复杂': '复杂的业务逻辑和数据流',
  '工具需求': '需要丰富的开发工具',
  '标准化': '需要团队开发标准化'
};

// Redux Toolkit配置
const store = configureStore({
  reducer: {
    user: userSlice.reducer,
    ui: uiSlice.reducer,
    data: dataSlice.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger, analytics)
});

// 优点：
// - 成熟稳定的解决方案
// - 强大的开发工具
// - 标准化的代码结构
// - 丰富的中间件生态
// - 优秀的调试能力
```

### 大型项目选择

#### 特征
- 组件数量 > 50个
- 复杂的业务逻辑
- 多团队协作
- 长期维护需求
- 高性能要求

#### 首选：Redux Toolkit

```jsx
// 企业级Redux Toolkit架构
// store/index.js
const store = configureStore({
  reducer: {
    auth: authSlice.reducer,
    users: usersSlice.reducer,
    products: productsSlice.reducer,
    orders: ordersSlice.reducer,
    ui: uiSlice.reducer,
    api: apiSlice.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      thunk: {
        extraArgument: { 
          api: apiClient,
          analytics: analyticsService 
        }
      }
    }).concat(
      listenerMiddleware.middleware,
      errorMiddleware,
      analyticsMiddleware
    ),
  devTools: process.env.NODE_ENV !== 'production'
});

// features/users/usersSlice.js
const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null
  }),
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        usersAdapter.setAll(state, action.payload);
        state.loading = false;
      });
  }
});

// 优势：
// - 标准化的代码组织
// - 强大的调试和开发工具
// - 成熟的最佳实践
// - 大型团队协作友好
// - 长期技术支持保证
```

#### 备选：Jotai

```jsx
// 适用于高性能要求的大型项目
// atoms/user.js
export const currentUserAtom = atom(null);
export const usersAtom = atom([]);
export const userSearchAtom = atom('');

// atoms/products.js
export const productsAtom = atom([]);
export const selectedProductAtom = atom(null);
export const productFiltersAtom = atom({});

// atoms/derived.js
export const filteredUsersAtom = atom((get) => {
  const users = get(usersAtom);
  const search = get(userSearchAtom);
  return users.filter(user => 
    user.name.toLowerCase().includes(search.toLowerCase())
  );
});

// 优势：
// - 最精确的性能控制
// - 灵活的状态组合
// - 适合复杂的状态依赖关系
// - 原子化设计利于模块化开发
```

### 特殊场景选择

#### 数据密集型应用

```jsx
// 推荐：React Query + 轻量状态管理
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { create } from 'zustand';

// 服务端状态用React Query
function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(r => r.json()),
    staleTime: 5 * 60 * 1000 // 5分钟
  });
}

// 客户端状态用Zustand
const useUIStore = create((set) => ({
  theme: 'light',
  sidebarOpen: false,
  setTheme: (theme) => set({ theme }),
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen }))
}));

// 优点：
// - 专业工具专业用途
// - React Query在数据获取方面无可匹敌
// - 简化了状态管理的复杂度
// - 自动缓存、重新获取、乐观更新等
```

#### 实时协作应用

```jsx
// 推荐：Jotai或Valtio + 实时同步
// Jotai方案
const documentAtom = atom({
  id: null,
  content: '',
  collaborators: [],
  version: 0
});

// 实时同步
const syncAtom = atom(
  null,
  (get, set, update) => {
    const currentDoc = get(documentAtom);
    
    // 乐观更新
    set(documentAtom, { ...currentDoc, ...update });
    
    // 同步到服务器
    websocket.send(JSON.stringify({
      type: 'document_update',
      docId: currentDoc.id,
      update,
      version: currentDoc.version + 1
    }));
  }
);

// Valtio方案
const documentState = proxy({
  content: '',
  collaborators: [],
  cursors: new Map()
});

// 直接修改，自动同步
documentState.content = 'new content';
documentState.collaborators.push({ id: 'user1', name: 'Alice' });
```

#### 移动端React Native

```jsx
// 推荐：Zustand（最简单）或Redux Toolkit（如果需要复杂功能）

// Zustand + AsyncStorage
import AsyncStorage from '@react-native-async-storage/async-storage';
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

const useAppStore = create(
  persist(
    (set) => ({
      user: null,
      settings: {},
      
      setUser: (user) => set({ user }),
      updateSettings: (settings) => set({ settings })
    }),
    {
      name: 'app-storage',
      storage: createJSONStorage(() => AsyncStorage)
    }
  )
);

// 优点：
// - 原生支持React Native
// - 简单的持久化
// - 良好的性能
// - 最小的学习成本
```

## 选择决策树

### 第一步：评估项目复杂度

```jsx
function assessProjectComplexity() {
  const complexity = {
    simple: {
      criteria: [
        '< 10个组件',
        '基础CRUD操作', 
        '简单的数据流',
        '无复杂业务逻辑'
      ],
      recommendations: ['useState/useReducer', 'Context API', 'Valtio'],
      avoidance: ['Redux', 'Recoil']
    },

    moderate: {
      criteria: [
        '10-50个组件',
        '中等业务逻辑',
        '多个数据源',
        '一些异步操作'
      ],
      recommendations: ['Zustand', 'Jotai', 'Context API'],
      conditionalRecommendations: {
        'Redux Toolkit': '团队熟悉Redux',
        'Valtio': '偏好直观API'
      }
    },

    complex: {
      criteria: [
        '50+个组件',
        '复杂业务逻辑',
        '复杂数据依赖',
        '大量异步操作'
      ],
      recommendations: ['Redux Toolkit', 'Jotai'],
      conditionalRecommendations: {
        'Zustand': '项目架构良好',
        'React Query + 轻量库': '数据获取为主'
      }
    }
  };

  return complexity;
}
```

### 第二步：评估团队能力

```jsx
function assessTeamCapability() {
  const teamAssessment = {
    beginner: {
      experience: '< 1年React经验',
      stateManagement: '仅使用过useState',
      recommendations: ['Valtio', 'Context API', 'Zustand'],
      focus: '快速上手，先实现功能',
      
      example: `
        // 推荐给初学者的简单方案
        const state = proxy({ count: 0 });
        
        function App() {
          const snap = useSnapshot(state);
          return (
            <button onClick={() => state.count++}>
              {snap.count}
            </button>
          );
        }
      `
    },

    intermediate: {
      experience: '1-3年React经验',
      stateManagement: '使用过Context API或Redux',
      recommendations: ['Zustand', 'Redux Toolkit', 'Jotai'],
      focus: '代码质量和可维护性',
      
      example: `
        // 适合中级团队的结构化方案
        const useStore = create((set) => ({
          user: null,
          login: async (creds) => {
            const user = await authAPI.login(creds);
            set({ user });
          }
        }));
      `
    },

    senior: {
      experience: '3+年React经验',
      stateManagement: '深度使用过多种状态管理方案',
      recommendations: ['基于项目需求选择', '可考虑任何方案'],
      focus: '架构设计和长期维护',
      
      considerations: [
        '技术债务',
        '性能优化',
        '团队知识传承',
        '方案迁移成本'
      ]
    }
  };

  return teamAssessment;
}
```

### 第三步：评估业务需求

```jsx
function assessBusinessRequirements() {
  const businessScenarios = {
    ecommerce: {
      characteristics: [
        '复杂的购物流程',
        '库存管理',
        '用户认证',
        '支付集成',
        '订单追踪'
      ],
      stateComplexity: '高',
      dataFetching: '重度',
      realtime: '中等',
      recommendations: {
        primary: 'Redux Toolkit + RTK Query',
        alternative: 'React Query + Zustand',
        reason: '复杂业务逻辑需要结构化管理'
      },
      
      implementation: `
        // Redux Toolkit方案
        const store = configureStore({
          reducer: {
            auth: authSlice.reducer,
            cart: cartSlice.reducer,
            products: productsSlice.reducer,
            orders: ordersSlice.reducer,
            api: apiSlice.reducer
          }
        });
      `
    },

    dashboard: {
      characteristics: [
        '大量数据可视化',
        '复杂过滤和搜索',
        '实时数据更新',
        '多图表交互'
      ],
      stateComplexity: '高',
      dataFetching: '重度',
      realtime: '高',
      recommendations: {
        primary: 'Jotai + React Query',
        alternative: 'Recoil + Suspense',
        reason: '原子化状态适合复杂数据依赖'
      },
      
      implementation: `
        // Jotai方案
        const rawDataAtom = atom([]);
        const filtersAtom = atom({});
        const chartDataAtom = atom((get) => {
          const data = get(rawDataAtom);
          const filters = get(filtersAtom);
          return processChartData(data, filters);
        });
      `
    },

    cms: {
      characteristics: [
        '内容编辑',
        '版本控制',
        '权限管理',
        '文件上传',
        '协作功能'
      ],
      stateComplexity: '高',
      dataFetching: '中等',
      realtime: '低',
      recommendations: {
        primary: 'Redux Toolkit',
        alternative: 'Zustand + Immer',
        reason: '需要可预测的状态更新和撤销/重做'
      }
    },

    socialMedia: {
      characteristics: [
        '无限滚动',
        '实时通知',
        '复杂的用户交互',
        '媒体处理'
      ],
      stateComplexity: '高',
      dataFetching: '重度',
      realtime: '高',
      recommendations: {
        primary: 'Jotai + React Query',
        alternative: 'Recoil + Suspense',
        reason: '需要处理复杂的数据关系和实时更新'
      }
    }
  };

  return businessScenarios;
}
```

## 实际选择案例

### 案例1：创业公司MVP

```jsx
// 背景：
// - 2-3人小团队
// - 快速验证产品概念
// - 开发时间紧张
// - 未来可能快速扩展

// 分析：
const mvpAnalysis = {
  priorities: ['开发速度', '简单易懂', '快速迭代'],
  constraints: ['时间紧张', '团队小', '经验有限'],
  
  decision: 'Valtio',
  
  reasons: [
    '学习成本最低',
    '开发速度最快',
    '代码最简洁',
    '后期容易迁移到其他方案'
  ],
  
  implementation: `
    // 最简单的实现
    const appState = proxy({
      user: null,
      products: [],
      cart: []
    });
    
    // 直接修改状态
    appState.user = userData;
    appState.cart.push(product);
  `
};

// 风险缓解：
const riskMitigation = [
  '设计良好的组件结构，便于后期重构',
  '使用TypeScript确保类型安全',
  '关键业务逻辑抽取到独立函数',
  '准备好迁移计划'
];
```

### 案例2：中型SaaS产品

```jsx
// 背景：
// - 10-15人开发团队
// - 中等复杂度的B2B产品
// - 多个功能模块
// - 需要长期维护

// 分析：
const saasAnalysis = {
  priorities: ['团队协作', '代码质量', '可维护性', '性能'],
  constraints: ['多人协作', '代码一致性', '新人培训'],
  
  decision: 'Zustand',
  
  reasons: [
    '简单易学，新人容易上手',
    '代码组织清晰',
    '性能优秀',
    'TypeScript支持好',
    '中间件满足扩展需求'
  ],
  
  architecture: `
    // 按功能模块拆分stores
    const useAuthStore = create((set) => ({...}));
    const useProjectsStore = create((set) => ({...}));
    const useTeamStore = create((set) => ({...}));
    
    // 使用中间件增强功能
    const useEnhancedStore = create(
      devtools(
        persist(storeConfig, { name: 'app-storage' }),
        { name: 'AppStore' }
      )
    );
  `,
  
  guidelines: [
    '制定store命名规范',
    '统一异步操作模式',
    '建立代码review流程',
    '编写详细的状态管理文档'
  ]
};
```

### 案例3：大型企业应用

```jsx
// 背景：
// - 50+人开发团队
// - 复杂的企业级功能
// - 多个子系统
// - 严格的质量要求

// 分析：
const enterpriseAnalysis = {
  priorities: ['稳定性', '可预测性', '团队标准化', '长期支持'],
  constraints: ['合规要求', '审计需求', '培训成本', '迁移风险'],
  
  decision: 'Redux Toolkit',
  
  reasons: [
    '最成熟稳定的方案',
    '强大的开发和调试工具',
    '标准化的开发模式',
    '丰富的企业级特性',
    '大量成功案例',
    '长期技术支持'
  ],
  
  architecture: `
    // 企业级架构
    const store = configureStore({
      reducer: {
        // 业务模块
        auth: authSlice.reducer,
        users: usersSlice.reducer,
        projects: projectsSlice.reducer,
        reports: reportsSlice.reducer,
        
        // 系统模块
        notifications: notificationsSlice.reducer,
        settings: settingsSlice.reducer,
        audit: auditSlice.reducer,
        
        // API模块
        api: apiSlice.reducer
      },
      
      middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
          thunk: {
            extraArgument: {
              api: apiClient,
              auth: authService,
              analytics: analyticsService,
              logger: loggerService
            }
          },
          serializableCheck: {
            ignoredActions: [
              // 忽略某些不可序列化的actions
            ]
          }
        }).concat(
          listenerMiddleware.middleware,
          errorHandlingMiddleware,
          auditMiddleware,
          performanceMiddleware
        )
    });
  `,
  
  governance: [
    '建立状态管理规范',
    '制定action命名约定',
    '设置代码质量门禁',
    '建立迁移和升级计划',
    '定期技术review'
  ]
};
```

## 迁移策略

### 渐进式迁移

```jsx
// 从Context API迁移到Zustand
// 阶段1：新功能使用Zustand
const useNewFeatureStore = create((set) => ({...}));

// 阶段2：将独立模块迁移
const useUserStore = create((set) => ({
  // 从UserContext迁移过来的状态
}));

// 阶段3：逐步替换所有Context
// 最终完全移除Context providers

// 从Redux迁移到现代方案
// 策略：
const migrationStrategy = {
  'Redux -> Redux Toolkit': {
    effort: '中等',
    risk: '低',
    benefits: '减少样板代码，改善开发体验',
    approach: '逐个slice迁移'
  },
  
  'Redux -> Zustand': {
    effort: '高',
    risk: '中等',
    benefits: '大幅简化代码，提升性能',
    approach: '重新设计状态结构'
  },
  
  'Any -> Jotai': {
    effort: '高',
    risk: '中等',
    benefits: '最佳性能，原子化设计',
    approach: '重新思考状态拆分'
  }
};
```

## 决策检查清单

### 技术选型清单

```jsx
const selectionChecklist = {
  // 项目评估
  project: [
    '✅ 项目规模和复杂度评估完成',
    '✅ 性能要求明确',
    '✅ 长期维护计划考虑',
    '✅ 技术债务风险评估'
  ],
  
  // 团队评估  
  team: [
    '✅ 团队技术能力评估完成',
    '✅ 学习时间和培训计划',
    '✅ 代码规范和标准制定',
    '✅ 知识传承计划'
  ],
  
  // 技术评估
  technology: [
    '✅ 库的稳定性和维护状态',
    '✅ 社区活跃度和支持情况',
    '✅ 文档质量和学习资源',
    '✅ TypeScript支持情况',
    '✅ 测试友好度',
    '✅ 调试工具可用性'
  ],
  
  // 业务评估
  business: [
    '✅ 业务需求和状态管理匹配度',
    '✅ 扩展性需求评估',
    '✅ 第三方集成需求',
    '✅ 安全和合规要求'
  ]
};
```

### 风险评估

```jsx
const riskAssessment = {
  'Context API': {
    risks: ['性能问题', 'Provider地狱', '复杂状态难管理'],
    mitigation: ['状态拆分', '性能优化', '使用useCallback/useMemo']
  },
  
  'Zustand': {
    risks: ['缺乏标准模式', '中间件生态相对小'],
    mitigation: ['建立团队规范', '选择性使用中间件']
  },
  
  'Valtio': {
    risks: ['Proxy兼容性', '调试复杂性', '学习曲线'],
    mitigation: ['现代浏览器支持良好', '使用开发工具', '团队培训']
  },
  
  'Jotai': {
    risks: ['原子设计复杂性', '社区相对较小'],
    mitigation: ['精心设计原子结构', '关注社区发展']
  },
  
  'Redux Toolkit': {
    risks: ['学习曲线陡峭', '样板代码', '概念复杂'],
    mitigation: ['充分培训', '建立最佳实践', '使用代码模板']
  },
  
  'Recoil': {
    risks: ['实验性质', 'Facebook内部项目风险', '社区较小'],
    mitigation: ['关注项目发展', '准备迁移方案', '谨慎使用']
  }
};
```

## 实用选择工具

### 在线选择器

```jsx
function StateManagementSelector() {
  const [answers, setAnswers] = useState({
    projectSize: '',
    teamExperience: '',
    businessComplexity: '',
    performanceNeeds: '',
    timeConstraints: ''
  });

  const getRecommendation = () => {
    const { projectSize, teamExperience, businessComplexity } = answers;
    
    // 简单决策逻辑
    if (projectSize === 'small' && teamExperience === 'beginner') {
      return 'Valtio';
    }
    
    if (projectSize === 'large' || businessComplexity === 'high') {
      return 'Redux Toolkit';
    }
    
    if (projectSize === 'medium' && teamExperience === 'intermediate') {
      return 'Zustand';
    }
    
    return 'Context API';
  };

  return (
    <div className="selector-tool">
      <h2>状态管理库选择器</h2>
      
      <div className="question">
        <label>项目规模？</label>
        <select onChange={(e) => setAnswers(prev => ({ ...prev, projectSize: e.target.value }))}>
          <option value="">请选择</option>
          <option value="small">小型 (<10组件)</option>
          <option value="medium">中型 (10-50组件)</option>
          <option value="large">大型 (50+组件)</option>
        </select>
      </div>
      
      <div className="question">
        <label>团队React经验？</label>
        <select onChange={(e) => setAnswers(prev => ({ ...prev, teamExperience: e.target.value }))}>
          <option value="">请选择</option>
          <option value="beginner">初级 (<1年)</option>
          <option value="intermediate">中级 (1-3年)</option>
          <option value="senior">高级 (3+年)</option>
        </select>
      </div>

      {/* 更多问题... */}

      <div className="recommendation">
        <h3>推荐方案：{getRecommendation()}</h3>
        <RecommendationDetails solution={getRecommendation()} />
      </div>
    </div>
  );
}
```

### 评分系统

```jsx
function scoringSoluttions(requirements) {
  const weights = {
    simplicity: requirements.simplicity || 0.2,
    performance: requirements.performance || 0.2,
    ecosystem: requirements.ecosystem || 0.15,
    typescript: requirements.typescript || 0.15,
    bundleSize: requirements.bundleSize || 0.1,
    devTools: requirements.devTools || 0.1,
    community: requirements.community || 0.1
  };

  const scores = {
    'Context API': {
      simplicity: 7, performance: 4, ecosystem: 6,
      typescript: 6, bundleSize: 10, devTools: 5, community: 9
    },
    'Zustand': {
      simplicity: 9, performance: 9, ecosystem: 7,
      typescript: 9, bundleSize: 10, devTools: 8, community: 7
    },
    'Valtio': {
      simplicity: 10, performance: 8, ecosystem: 6,
      typescript: 10, bundleSize: 8, devTools: 6, community: 6
    },
    'Jotai': {
      simplicity: 7, performance: 10, ecosystem: 7,
      typescript: 10, bundleSize: 9, devTools: 7, community: 6
    },
    'Redux Toolkit': {
      simplicity: 5, performance: 8, ecosystem: 10,
      typescript: 8, bundleSize: 6, devTools: 10, community: 10
    },
    'Recoil': {
      simplicity: 6, performance: 8, ecosystem: 6,
      typescript: 7, bundleSize: 5, devTools: 9, community: 5
    }
  };

  // 计算加权总分
  const finalScores = Object.entries(scores).map(([solution, solutionScores]) => {
    const totalScore = Object.entries(weights).reduce((sum, [criterion, weight]) => {
      return sum + (solutionScores[criterion] * weight);
    }, 0);
    
    return { solution, score: totalScore.toFixed(2) };
  });

  return finalScores.sort((a, b) => b.score - a.score);
}

// 使用示例
const requirements = {
  simplicity: 0.3,    // 简洁性权重30%
  performance: 0.25,  // 性能权重25%
  typescript: 0.2,    // TypeScript权重20%
  ecosystem: 0.15,    // 生态权重15%
  community: 0.1      // 社区权重10%
};

const recommendations = scoringSoluttions(requirements);
// 结果：根据权重计算出的推荐排序
```

## 总结

选择状态管理库需要综合考虑多个因素：

### 快速选择指南

1. **初学者/小项目**：Valtio（最简单）
2. **平衡选择**：Zustand（综合最佳）
3. **大型项目**：Redux Toolkit（最成熟）
4. **高性能需求**：Jotai（最精确）
5. **数据获取为主**：React Query + 轻量库

### 核心原则

1. **项目优先**：根据项目实际需求选择，避免过度设计
2. **团队适配**：考虑团队技术水平和学习能力
3. **长远考虑**：评估长期维护和扩展需求
4. **渐进迁移**：可以从简单方案开始，后期渐进升级

记住：没有最好的状态管理库，只有最适合的选择。
