# åŠ¨æ€è·¯ç”±ä¸å‚æ•°è·å–

## æ¦‚è¿°

åŠ¨æ€è·¯ç”±æ˜¯ç°ä»£Webåº”ç”¨çš„æ ¸å¿ƒç‰¹æ€§ï¼Œå…è®¸æ ¹æ®URLå‚æ•°åŠ¨æ€æ¸²æŸ“ä¸åŒçš„å†…å®¹ã€‚React Router v6æä¾›äº†å¼ºå¤§çš„å‚æ•°è·å–å’Œå¤„ç†æœºåˆ¶ï¼ŒåŒ…æ‹¬è·¯å¾„å‚æ•°ã€æŸ¥è¯¢å‚æ•°ã€çŠ¶æ€ä¼ é€’ç­‰å¤šç§æ–¹å¼ã€‚

## è·¯å¾„å‚æ•°è¯¦è§£

### åŸºç¡€è·¯å¾„å‚æ•°

```jsx
import { useParams, Link } from 'react-router-dom';

// è·¯ç”±å®šä¹‰
<Routes>
  <Route path="/users/:userId" element={<UserProfile />} />
  <Route path="/products/:category/:productId" element={<ProductDetail />} />
  <Route path="/blog/:year/:month/:day/:slug" element={<BlogPost />} />
</Routes>

// è·å–å•ä¸ªå‚æ•°
function UserProfile() {
  const { userId } = useParams();
  
  // userId æ€»æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œéœ€è¦è½¬æ¢
  const numericUserId = parseInt(userId, 10);
  
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(numericUserId)
      .then(setUser)
      .catch(console.error)
      .finally(() => setLoading(false));
  }, [numericUserId]);

  if (loading) return <div>Loading user...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      <p>User ID: {userId}</p>
      
      {/* ç›¸å…³é“¾æ¥ */}
      <nav>
        <Link to={`/users/${userId}/posts`}>Posts</Link>
        <Link to={`/users/${userId}/followers`}>Followers</Link>
        <Link to={`/users/${userId}/settings`}>Settings</Link>
      </nav>
    </div>
  );
}

// è·å–å¤šä¸ªå‚æ•°
function ProductDetail() {
  const { category, productId } = useParams();
  const [product, setProduct] = useState(null);

  useEffect(() => {
    fetchProductByCategory(category, productId)
      .then(setProduct);
  }, [category, productId]);

  return (
    <div className="product-detail">
      <nav className="breadcrumb">
        <Link to="/products">Products</Link>
        <span> / </span>
        <Link to={`/products/category/${category}`}>{category}</Link>
        <span> / </span>
        <span>{product?.name}</span>
      </nav>

      {product && (
        <div className="product-info">
          <h1>{product.name}</h1>
          <p>Category: {category}</p>
          <p>Product ID: {productId}</p>
          <p>Price: ${product.price}</p>
        </div>
      )}
    </div>
  );
}

// å¤æ‚è·¯å¾„å‚æ•°
function BlogPost() {
  const { year, month, day, slug } = useParams();
  
  const postDate = new Date(`${year}-${month}-${day}`);
  const formattedDate = postDate.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  const [post, setPost] = useState(null);

  useEffect(() => {
    fetchPostByDate(year, month, day, slug)
      .then(setPost);
  }, [year, month, day, slug]);

  return (
    <article className="blog-post">
      <header>
        <h1>{post?.title}</h1>
        <time dateTime={`${year}-${month}-${day}`}>
          Published on {formattedDate}
        </time>
        <div className="post-meta">
          <Link to={`/blog/${year}`}>Posts from {year}</Link>
          <Link to={`/blog/${year}/${month}`}>Posts from {formattedDate.split(' ')[0]} {year}</Link>
        </div>
      </header>
      
      {post && (
        <div className="post-content">
          <div dangerouslySetInnerHTML={{ __html: post.content }} />
        </div>
      )}
    </article>
  );
}
```

### å¯é€‰å‚æ•°

```jsx
// è·¯ç”±å®šä¹‰ - ä½¿ç”¨ ? è¡¨ç¤ºå¯é€‰å‚æ•°
<Routes>
  <Route path="/blog/:year?/:month?/:day?" element={<BlogArchive />} />
  <Route path="/shop/:category?/:subcategory?" element={<Shop />} />
</Routes>

function BlogArchive() {
  const { year, month, day } = useParams();
  const [posts, setPosts] = useState([]);

  // æ ¹æ®å‚æ•°æ„å»ºè¿‡æ»¤æ¡ä»¶
  const buildDateFilter = useCallback(() => {
    const filter = {};
    
    if (year) {
      filter.year = parseInt(year, 10);
      
      if (month) {
        filter.month = parseInt(month, 10);
        
        if (day) {
          filter.day = parseInt(day, 10);
        }
      }
    }
    
    return filter;
  }, [year, month, day]);

  useEffect(() => {
    const dateFilter = buildDateFilter();
    fetchPosts(dateFilter).then(setPosts);
  }, [buildDateFilter]);

  const getArchiveTitle = () => {
    if (day && month && year) {
      return `Posts from ${month}/${day}/${year}`;
    } else if (month && year) {
      return `Posts from ${month}/${year}`;
    } else if (year) {
      return `Posts from ${year}`;
    } else {
      return 'All Posts';
    }
  };

  return (
    <div className="blog-archive">
      <header>
        <h1>{getArchiveTitle()}</h1>
        
        {/* å¯¼èˆªé“¾æ¥ */}
        <nav className="archive-nav">
          <Link to="/blog">All Years</Link>
          {year && (
            <>
              <span> / </span>
              <Link to={`/blog/${year}`}>{year}</Link>
            </>
          )}
          {month && year && (
            <>
              <span> / </span>
              <Link to={`/blog/${year}/${month}`}>{month}</Link>
            </>
          )}
          {day && month && year && (
            <>
              <span> / </span>
              <span>{day}</span>
            </>
          )}
        </nav>
      </header>

      <div className="posts-list">
        {posts.map(post => (
          <article key={post.id} className="post-preview">
            <h2>
              <Link to={`/blog/${post.year}/${post.month}/${post.day}/${post.slug}`}>
                {post.title}
              </Link>
            </h2>
            <time>{post.publishedAt}</time>
            <p>{post.excerpt}</p>
          </article>
        ))}
      </div>
    </div>
  );
}

// å•†åº—é¡µé¢withå¯é€‰å‚æ•°
function Shop() {
  const { category, subcategory } = useParams();
  const [products, setProducts] = useState([]);
  const [categories, setCategories] = useState([]);

  useEffect(() => {
    // æ ¹æ®å‚æ•°è·å–äº§å“
    const filters = {};
    if (category) filters.category = category;
    if (subcategory) filters.subcategory = subcategory;
    
    fetchProducts(filters).then(setProducts);
  }, [category, subcategory]);

  useEffect(() => {
    // è·å–åˆ†ç±»åˆ—è¡¨
    fetchCategories().then(setCategories);
  }, []);

  return (
    <div className="shop">
      <aside className="categories-sidebar">
        <h3>Categories</h3>
        <ul>
          <li>
            <Link to="/shop" className={!category ? 'active' : ''}>
              All Products
            </Link>
          </li>
          {categories.map(cat => (
            <li key={cat.id}>
              <Link 
                to={`/shop/${cat.slug}`}
                className={category === cat.slug ? 'active' : ''}
              >
                {cat.name}
              </Link>
              
              {/* å­åˆ†ç±» */}
              {category === cat.slug && cat.subcategories && (
                <ul className="subcategories">
                  {cat.subcategories.map(subcat => (
                    <li key={subcat.id}>
                      <Link 
                        to={`/shop/${cat.slug}/${subcat.slug}`}
                        className={subcategory === subcat.slug ? 'active' : ''}
                      >
                        {subcat.name}
                      </Link>
                    </li>
                  ))}
                </ul>
              )}
            </li>
          ))}
        </ul>
      </aside>

      <main className="products-main">
        <header>
          <h1>
            {subcategory ? `${subcategory} in ${category}` :
             category ? category :
             'All Products'}
          </h1>
          <p>{products.length} products found</p>
        </header>

        <ProductGrid products={products} />
      </main>
    </div>
  );
}
```

### å‚æ•°éªŒè¯å’Œè½¬æ¢

```jsx
// è‡ªå®šä¹‰Hookè¿›è¡Œå‚æ•°éªŒè¯
function useValidatedParams(schema) {
  const params = useParams();
  const navigate = useNavigate();

  const validatedParams = useMemo(() => {
    const result = {};
    const errors = [];

    Object.entries(schema).forEach(([key, validator]) => {
      const value = params[key];
      
      try {
        result[key] = validator(value);
      } catch (error) {
        errors.push({ key, error: error.message });
      }
    });

    if (errors.length > 0) {
      console.error('Parameter validation errors:', errors);
      navigate('/404', { replace: true });
      return null;
    }

    return result;
  }, [params, schema, navigate]);

  return validatedParams;
}

// éªŒè¯å™¨å‡½æ•°
const validators = {
  positiveInteger: (value) => {
    const num = parseInt(value, 10);
    if (isNaN(num) || num <= 0) {
      throw new Error('Must be a positive integer');
    }
    return num;
  },
  
  slug: (value) => {
    if (!/^[a-z0-9-]+$/.test(value)) {
      throw new Error('Invalid slug format');
    }
    return value;
  },
  
  date: (value) => {
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      throw new Error('Invalid date format');
    }
    return date;
  }
};

// ä½¿ç”¨å‚æ•°éªŒè¯
function ValidatedUserProfile() {
  const params = useValidatedParams({
    userId: validators.positiveInteger
  });

  if (!params) return null; // éªŒè¯å¤±è´¥ï¼Œä¼šé‡å®šå‘

  const { userId } = params;

  return (
    <div>
      <h1>User #{userId}</h1>
    </div>
  );
}

function ValidatedBlogPost() {
  const params = useValidatedParams({
    year: (value) => {
      const year = parseInt(value, 10);
      const currentYear = new Date().getFullYear();
      if (year < 2000 || year > currentYear) {
        throw new Error('Year must be between 2000 and current year');
      }
      return year;
    },
    month: (value) => {
      const month = parseInt(value, 10);
      if (month < 1 || month > 12) {
        throw new Error('Month must be between 1 and 12');
      }
      return month;
    },
    slug: validators.slug
  });

  // ä½¿ç”¨éªŒè¯åçš„å‚æ•°...
}
```

## æŸ¥è¯¢å‚æ•°ç®¡ç†

### useSearchParamsè¯¦è§£

```jsx
import { useSearchParams, useNavigate } from 'react-router-dom';

function ProductsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const navigate = useNavigate();

  // è·å–æŸ¥è¯¢å‚æ•°
  const currentFilters = {
    category: searchParams.get('category') || '',
    minPrice: parseFloat(searchParams.get('minPrice')) || 0,
    maxPrice: parseFloat(searchParams.get('maxPrice')) || 1000,
    sortBy: searchParams.get('sortBy') || 'name',
    order: searchParams.get('order') || 'asc',
    page: parseInt(searchParams.get('page')) || 1,
    limit: parseInt(searchParams.get('limit')) || 12,
    inStock: searchParams.get('inStock') === 'true',
    onSale: searchParams.get('onSale') === 'true',
    brand: searchParams.getAll('brand') // è·å–å¤šä¸ªåŒåå‚æ•°
  };

  // æ›´æ–°å•ä¸ªå‚æ•°
  const updateFilter = (key, value) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (value === '' || value === null || value === undefined) {
      newParams.delete(key);
    } else {
      newParams.set(key, value.toString());
    }
    
    // é‡ç½®é¡µç 
    if (key !== 'page') {
      newParams.set('page', '1');
    }
    
    setSearchParams(newParams);
  };

  // æ‰¹é‡æ›´æ–°å‚æ•°
  const updateFilters = (updates) => {
    setSearchParams(prev => {
      const newParams = new URLSearchParams(prev);
      
      Object.entries(updates).forEach(([key, value]) => {
        if (value === '' || value === null || value === undefined) {
          newParams.delete(key);
        } else if (Array.isArray(value)) {
          newParams.delete(key);
          value.forEach(v => newParams.append(key, v));
        } else {
          newParams.set(key, value.toString());
        }
      });
      
      return newParams;
    });
  };

  // æ¸…é™¤ç‰¹å®šè¿‡æ»¤å™¨
  const clearFilter = (key) => {
    setSearchParams(prev => {
      const newParams = new URLSearchParams(prev);
      newParams.delete(key);
      return newParams;
    });
  };

  // æ¸…é™¤æ‰€æœ‰è¿‡æ»¤å™¨
  const clearAllFilters = () => {
    setSearchParams({});
  };

  // æ·»åŠ åˆ°æ”¶è—å¤¹ï¼ˆä¿æŒå½“å‰è¿‡æ»¤å™¨ï¼‰
  const addToFavorites = () => {
    const currentUrl = `${location.pathname}?${searchParams.toString()}`;
    addFavoriteUrl(currentUrl, 'Filtered Products');
  };

  return (
    <div className="products-page">
      {/* è¿‡æ»¤å™¨åŒºåŸŸ */}
      <aside className="filters-sidebar">
        <h3>Filters</h3>
        
        {/* åˆ†ç±»è¿‡æ»¤å™¨ */}
        <div className="filter-group">
          <label>Category</label>
          <select
            value={currentFilters.category}
            onChange={(e) => updateFilter('category', e.target.value)}
          >
            <option value="">All Categories</option>
            <option value="electronics">Electronics</option>
            <option value="clothing">Clothing</option>
            <option value="books">Books</option>
          </select>
        </div>

        {/* ä»·æ ¼èŒƒå›´ */}
        <div className="filter-group">
          <label>Price Range</label>
          <input
            type="number"
            placeholder="Min Price"
            value={currentFilters.minPrice}
            onChange={(e) => updateFilter('minPrice', e.target.value)}
          />
          <input
            type="number"
            placeholder="Max Price"
            value={currentFilters.maxPrice}
            onChange={(e) => updateFilter('maxPrice', e.target.value)}
          />
        </div>

        {/* å¤é€‰æ¡†è¿‡æ»¤å™¨ */}
        <div className="filter-group">
          <label>
            <input
              type="checkbox"
              checked={currentFilters.inStock}
              onChange={(e) => updateFilter('inStock', e.target.checked)}
            />
            In Stock Only
          </label>
          
          <label>
            <input
              type="checkbox"
              checked={currentFilters.onSale}
              onChange={(e) => updateFilter('onSale', e.target.checked)}
            />
            On Sale
          </label>
        </div>

        {/* å¤šé€‰è¿‡æ»¤å™¨ */}
        <div className="filter-group">
          <label>Brands</label>
          <div className="checkbox-group">
            {['Apple', 'Samsung', 'Google', 'Microsoft'].map(brand => (
              <label key={brand}>
                <input
                  type="checkbox"
                  checked={currentFilters.brand.includes(brand)}
                  onChange={(e) => {
                    const newBrands = e.target.checked
                      ? [...currentFilters.brand, brand]
                      : currentFilters.brand.filter(b => b !== brand);
                    updateFilter('brand', newBrands);
                  }}
                />
                {brand}
              </label>
            ))}
          </div>
        </div>

        <div className="filter-actions">
          <button onClick={clearAllFilters}>Clear All</button>
          <button onClick={addToFavorites}>Save Filters</button>
        </div>
      </aside>

      {/* äº§å“åˆ—è¡¨åŒºåŸŸ */}
      <main className="products-main">
        <header className="products-header">
          <h1>Products</h1>
          
          {/* æ’åºæ§ä»¶ */}
          <div className="sort-controls">
            <select
              value={`${currentFilters.sortBy}-${currentFilters.order}`}
              onChange={(e) => {
                const [sortBy, order] = e.target.value.split('-');
                updateFilters({ sortBy, order });
              }}
            >
              <option value="name-asc">Name (A-Z)</option>
              <option value="name-desc">Name (Z-A)</option>
              <option value="price-asc">Price (Low to High)</option>
              <option value="price-desc">Price (High to Low)</option>
              <option value="date-desc">Newest First</option>
              <option value="rating-desc">Highest Rated</option>
            </select>
          </div>

          {/* æ˜¾ç¤ºæ•°é‡æ§ä»¶ */}
          <div className="limit-controls">
            <label>Show: </label>
            <select
              value={currentFilters.limit}
              onChange={(e) => updateFilter('limit', e.target.value)}
            >
              <option value="12">12 per page</option>
              <option value="24">24 per page</option>
              <option value="48">48 per page</option>
            </select>
          </div>
        </header>

        {/* æ´»è·ƒè¿‡æ»¤å™¨æ˜¾ç¤º */}
        <ActiveFilters 
          filters={currentFilters} 
          onRemoveFilter={clearFilter}
        />

        {/* äº§å“ç½‘æ ¼ */}
        <ProductGrid 
          products={products}
          loading={loading}
        />

        {/* åˆ†é¡µ */}
        <Pagination
          currentPage={currentFilters.page}
          totalPages={totalPages}
          onPageChange={(page) => updateFilter('page', page)}
        />
      </main>
    </div>
  );
}

// æ´»è·ƒè¿‡æ»¤å™¨ç»„ä»¶
function ActiveFilters({ filters, onRemoveFilter }) {
  const activeFilters = Object.entries(filters)
    .filter(([key, value]) => {
      if (key === 'page' || key === 'limit') return false;
      if (Array.isArray(value)) return value.length > 0;
      return value !== '' && value !== 0 && value !== false;
    });

  if (activeFilters.length === 0) return null;

  return (
    <div className="active-filters">
      <span>Active filters:</span>
      {activeFilters.map(([key, value]) => (
        <div key={key} className="filter-tag">
          <span>{key}: {Array.isArray(value) ? value.join(', ') : value.toString()}</span>
          <button onClick={() => onRemoveFilter(key)}>Ã—</button>
        </div>
      ))}
    </div>
  );
}
```

### æŸ¥è¯¢å‚æ•°æŒä¹…åŒ–

```jsx
// è‡ªå®šä¹‰Hookï¼šæŒä¹…åŒ–æŸ¥è¯¢å‚æ•°
function usePersistentSearchParams(storageKey, defaultParams = {}) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // ä»localStorageæ¢å¤å‚æ•°
  useEffect(() => {
    const saved = localStorage.getItem(storageKey);
    if (saved) {
      try {
        const savedParams = JSON.parse(saved);
        const urlParams = new URLSearchParams();
        
        Object.entries({...defaultParams, ...savedParams}).forEach(([key, value]) => {
          if (value !== '' && value !== null && value !== undefined) {
            urlParams.set(key, value.toString());
          }
        });
        
        setSearchParams(urlParams, { replace: true });
      } catch (error) {
        console.error('Failed to restore search params:', error);
      }
    }
  }, [storageKey, setSearchParams]);

  // ä¿å­˜å‚æ•°åˆ°localStorage
  useEffect(() => {
    const paramsObject = Object.fromEntries(searchParams);
    localStorage.setItem(storageKey, JSON.stringify(paramsObject));
  }, [searchParams, storageKey]);

  return [searchParams, setSearchParams];
}

// ä½¿ç”¨æŒä¹…åŒ–å‚æ•°
function ProductsWithPersistentFilters() {
  const [searchParams, setSearchParams] = usePersistentSearchParams(
    'products-filters',
    { sortBy: 'name', order: 'asc', limit: '12' }
  );

  // å…¶ä½™é€»è¾‘...
}
```

## åŠ¨æ€è·¯ç”±ç”Ÿæˆ

### åŸºäºæ•°æ®çš„è·¯ç”±

```jsx
// åŠ¨æ€ç”Ÿæˆè·¯ç”±é…ç½®
function createDynamicRoutes(categories, userRole) {
  const routes = [
    {
      path: '/',
      element: <Layout />,
      children: [
        { index: true, element: <Home /> }
      ]
    }
  ];

  // æ ¹æ®åˆ†ç±»æ•°æ®ç”Ÿæˆè·¯ç”±
  const categoryRoutes = categories.map(category => ({
    path: `category/${category.slug}`,
    element: <CategoryPage />,
    loader: ({ params }) => loadCategoryData(params.slug),
    children: category.subcategories?.map(sub => ({
      path: sub.slug,
      element: <SubcategoryPage />,
      loader: ({ params }) => loadSubcategoryData(params)
    })) || []
  }));

  routes[0].children.push(...categoryRoutes);

  // æ ¹æ®ç”¨æˆ·è§’è‰²æ·»åŠ è·¯ç”±
  if (userRole === 'admin') {
    routes[0].children.push({
      path: 'admin',
      element: <AdminPanel />,
      children: [
        { index: true, element: <AdminDashboard /> },
        { path: 'categories', element: <ManageCategories /> }
      ]
    });
  }

  return routes;
}

// åŠ¨æ€è·¯ç”±Provider
function DynamicRoutesProvider({ children }) {
  const [categories, setCategories] = useState([]);
  const [userRole, setUserRole] = useState(null);
  const [router, setRouter] = useState(null);

  useEffect(() => {
    Promise.all([
      fetchCategories(),
      fetchUserRole()
    ]).then(([cats, role]) => {
      setCategories(cats);
      setUserRole(role);
      
      const routes = createDynamicRoutes(cats, role);
      setRouter(createBrowserRouter(routes));
    });
  }, []);

  if (!router) return <div>Loading application...</div>;

  return <RouterProvider router={router} />;
}
```

### æ¡ä»¶è·¯ç”±æ¸²æŸ“

```jsx
// åŸºäºåŠŸèƒ½æ ‡å¿—çš„è·¯ç”±
function FeatureFlagRoutes() {
  const { features } = useFeatureFlags();

  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        
        {/* åŸºç¡€åŠŸèƒ½è·¯ç”± */}
        <Route path="products" element={<Products />} />
        <Route path="about" element={<About />} />
        
        {/* æ¡ä»¶è·¯ç”± - åªåœ¨åŠŸèƒ½å¯ç”¨æ—¶æ˜¾ç¤º */}
        {features.analytics && (
          <Route path="analytics" element={<Analytics />} />
        )}
        
        {features.advanced_search && (
          <Route path="search" element={<AdvancedSearch />} />
        )}
        
        {features.social_features && (
          <Route path="social" element={<SocialLayout />}>
            <Route index element={<SocialFeed />} />
            <Route path="friends" element={<Friends />} />
            <Route path="messages" element={<Messages />} />
          </Route>
        )}
        
        {/* åŸºäºç”¨æˆ·ç±»å‹çš„è·¯ç”± */}
        <Route path="dashboard" element={<DashboardSelector />} />
      </Route>
    </Routes>
  );
}

function DashboardSelector() {
  const { user } = useAuth();

  // æ ¹æ®ç”¨æˆ·ç±»å‹æ¸²æŸ“ä¸åŒçš„ä»ªè¡¨æ¿
  switch (user.type) {
    case 'admin':
      return <AdminDashboard />;
    case 'manager':
      return <ManagerDashboard />;
    case 'customer':
      return <CustomerDashboard />;
    default:
      return <Navigate to="/login" replace />;
  }
}

// å®éªŒæ€§è·¯ç”±
function ExperimentalRoutes() {
  const { experiments } = useExperiments();

  return (
    <Routes>
      <Route path="/experiment" element={<ExperimentLayout />}>
        {experiments.includes('new-ui') && (
          <Route path="new-ui" element={<NewUIExperiment />} />
        )}
        
        {experiments.includes('beta-features') && (
          <Route path="beta" element={<BetaFeatures />} />
        )}
      </Route>
    </Routes>
  );
}
```

## é«˜çº§å‚æ•°æ¨¡å¼

### å‚æ•°è§£æå’ŒéªŒè¯

```jsx
// å¤åˆå‚æ•°è§£æ
function useCompoundParams() {
  const { compoundParam } = useParams();
  
  const parseCompoundParam = useCallback((param) => {
    if (!param) return null;
    
    // è§£æå¤åˆå‚æ•°ï¼šuserId-postId-commentId
    const parts = param.split('-');
    
    if (parts.length !== 3) {
      throw new Error('Invalid compound parameter format');
    }
    
    return {
      userId: parseInt(parts[0], 10),
      postId: parseInt(parts[1], 10),
      commentId: parseInt(parts[2], 10)
    };
  }, []);

  const params = useMemo(() => {
    try {
      return parseCompoundParam(compoundParam);
    } catch (error) {
      console.error('Parameter parsing error:', error);
      return null;
    }
  }, [compoundParam, parseCompoundParam]);

  return params;
}

// è·¯ç”±å®šä¹‰
<Route path="/thread/:compoundParam" element={<ThreadDetail />} />

// ä½¿ç”¨
function ThreadDetail() {
  const params = useCompoundParams();
  const navigate = useNavigate();

  if (!params) {
    navigate('/404', { replace: true });
    return null;
  }

  const { userId, postId, commentId } = params;

  return (
    <div>
      <h1>Comment Detail</h1>
      <p>User ID: {userId}</p>
      <p>Post ID: {postId}</p>
      <p>Comment ID: {commentId}</p>
    </div>
  );
}
```

### å‚æ•°å˜æ¢å’Œæ˜ å°„

```jsx
// å‚æ•°å˜æ¢Hook
function useTransformedParams(transformers) {
  const rawParams = useParams();
  
  return useMemo(() => {
    const transformed = {};
    
    Object.entries(rawParams).forEach(([key, value]) => {
      const transformer = transformers[key];
      transformed[key] = transformer ? transformer(value) : value;
    });
    
    return transformed;
  }, [rawParams, transformers]);
}

// å‚æ•°å˜æ¢å™¨
const paramTransformers = {
  userId: (value) => parseInt(value, 10),
  slug: (value) => decodeURIComponent(value),
  date: (value) => new Date(value),
  coordinates: (value) => {
    const [lat, lng] = value.split(',');
    return {
      latitude: parseFloat(lat),
      longitude: parseFloat(lng)
    };
  },
  tags: (value) => value.split('+').map(decodeURIComponent)
};

// ä½¿ç”¨å˜æ¢åçš„å‚æ•°
function TransformedParamsComponent() {
  const params = useTransformedParams(paramTransformers);
  
  // params.userId ç°åœ¨æ˜¯æ•°å­—ç±»å‹
  // params.date ç°åœ¨æ˜¯Dateå¯¹è±¡
  // params.coordinates ç°åœ¨æ˜¯å¯¹è±¡ {latitude, longitude}
  
  return (
    <div>
      <p>User ID: {params.userId}</p>
      <p>Date: {params.date?.toLocaleDateString()}</p>
      <p>Location: {params.coordinates?.latitude}, {params.coordinates?.longitude}</p>
    </div>
  );
}
```

### å‚æ•°åŒæ­¥åˆ°çŠ¶æ€

```jsx
// å°†URLå‚æ•°åŒæ­¥åˆ°ç»„ä»¶çŠ¶æ€
function useParamsSync(paramKey, defaultValue, parser = (v) => v) {
  const [searchParams, setSearchParams] = useSearchParams();
  const paramValue = searchParams.get(paramKey);

  const [localState, setLocalState] = useState(() => {
    return paramValue ? parser(paramValue) : defaultValue;
  });

  // å‚æ•°å˜åŒ–æ—¶æ›´æ–°æœ¬åœ°çŠ¶æ€
  useEffect(() => {
    if (paramValue !== null) {
      setLocalState(parser(paramValue));
    }
  }, [paramValue, parser]);

  // æ›´æ–°å‡½æ•°åŒæ—¶æ›´æ–°URLå’Œæœ¬åœ°çŠ¶æ€
  const updateValue = useCallback((newValue) => {
    setLocalState(newValue);
    
    if (newValue === defaultValue) {
      // å¦‚æœæ˜¯é»˜è®¤å€¼ï¼Œä»URLä¸­ç§»é™¤å‚æ•°
      setSearchParams(prev => {
        const newParams = new URLSearchParams(prev);
        newParams.delete(paramKey);
        return newParams;
      });
    } else {
      setSearchParams(prev => {
        const newParams = new URLSearchParams(prev);
        newParams.set(paramKey, newValue.toString());
        return newParams;
      });
    }
  }, [paramKey, defaultValue, setSearchParams]);

  return [localState, updateValue];
}

// ä½¿ç”¨å‚æ•°åŒæ­¥
function SearchPage() {
  const [query, setQuery] = useParamsSync('q', '');
  const [sortBy, setSortBy] = useParamsSync('sort', 'relevance');
  const [page, setPage] = useParamsSync('page', 1, parseInt);

  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  // å‚æ•°å˜åŒ–æ—¶æ‰§è¡Œæœç´¢
  useEffect(() => {
    if (query) {
      setLoading(true);
      searchAPI(query, { sortBy, page })
        .then(setResults)
        .finally(() => setLoading(false));
    }
  }, [query, sortBy, page]);

  return (
    <div className="search-page">
      <header className="search-header">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search..."
        />
        
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="relevance">Most Relevant</option>
          <option value="date">Newest</option>
          <option value="popularity">Most Popular</option>
        </select>
      </header>

      {loading ? (
        <div>Searching...</div>
      ) : (
        <SearchResults results={results} />
      )}

      <Pagination
        current={page}
        onChange={setPage}
      />
    </div>
  );
}
```

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šæ–‡ä»¶ç®¡ç†å™¨

```jsx
function FileManager() {
  return (
    <Routes>
      <Route path="/files" element={<FileManagerLayout />}>
        {/* æ ¹ç›®å½• */}
        <Route index element={<FilesRoot />} />
        
        {/* æ–‡ä»¶å¤¹è·¯å¾„ - æ”¯æŒä»»æ„æ·±åº¦ */}
        <Route path="*" element={<FolderView />} />
      </Route>
    </Routes>
  );
}

function FolderView() {
  const location = useLocation();
  const navigate = useNavigate();
  
  // ä»è·¯å¾„è§£ææ–‡ä»¶å¤¹å±‚çº§
  const folderPath = location.pathname.replace('/files/', '') || '';
  const pathSegments = folderPath ? folderPath.split('/') : [];
  
  const [files, setFiles] = useState([]);
  const [folders, setFolders] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchFolderContents(folderPath)
      .then(({ files, folders }) => {
        setFiles(files);
        setFolders(folders);
      })
      .finally(() => setLoading(false));
  }, [folderPath]);

  const navigateToFolder = (folderName) => {
    const newPath = folderPath ? `${folderPath}/${folderName}` : folderName;
    navigate(`/files/${newPath}`);
  };

  const navigateUp = () => {
    if (pathSegments.length > 0) {
      const parentPath = pathSegments.slice(0, -1).join('/');
      navigate(`/files/${parentPath}`);
    }
  };

  if (loading) return <div>Loading folder contents...</div>;

  return (
    <div className="folder-view">
      {/* è·¯å¾„å¯¼èˆª */}
      <nav className="folder-breadcrumb">
        <Link to="/files">Files</Link>
        {pathSegments.map((segment, index) => {
          const segmentPath = pathSegments.slice(0, index + 1).join('/');
          return (
            <span key={index}>
              <span className="separator"> / </span>
              <Link to={`/files/${segmentPath}`}>
                {decodeURIComponent(segment)}
              </Link>
            </span>
          );
        })}
      </nav>

      {/* æ“ä½œæ  */}
      <div className="folder-actions">
        {pathSegments.length > 0 && (
          <button onClick={navigateUp}>
            â† Back to Parent Folder
          </button>
        )}
        
        <button onClick={() => setShowUploadModal(true)}>
          Upload Files
        </button>
        
        <button onClick={() => setShowCreateFolderModal(true)}>
          New Folder
        </button>
      </div>

      {/* æ–‡ä»¶å¤¹åˆ—è¡¨ */}
      {folders.length > 0 && (
        <div className="folders-grid">
          <h3>Folders</h3>
          {folders.map(folder => (
            <div
              key={folder.id}
              className="folder-item"
              onClick={() => navigateToFolder(folder.name)}
            >
              <div className="folder-icon">ğŸ“</div>
              <span className="folder-name">{folder.name}</span>
              <span className="folder-size">{folder.itemCount} items</span>
            </div>
          ))}
        </div>
      )}

      {/* æ–‡ä»¶åˆ—è¡¨ */}
      {files.length > 0 && (
        <div className="files-grid">
          <h3>Files</h3>
          {files.map(file => (
            <div key={file.id} className="file-item">
              <div className="file-icon">
                {getFileIcon(file.type)}
              </div>
              <span className="file-name">{file.name}</span>
              <span className="file-size">{formatFileSize(file.size)}</span>
              <time className="file-modified">
                {new Date(file.modifiedAt).toLocaleDateString()}
              </time>
            </div>
          ))}
        </div>
      )}

      {folders.length === 0 && files.length === 0 && (
        <div className="empty-folder">
          <p>This folder is empty</p>
        </div>
      )}
    </div>
  );
}
```

### æ¡ˆä¾‹2ï¼šå¤šè¯­è¨€è·¯ç”±

```jsx
// æ”¯æŒå¤šè¯­è¨€çš„è·¯ç”±ç³»ç»Ÿ
const SUPPORTED_LOCALES = ['en', 'zh', 'ja', 'ko'];
const DEFAULT_LOCALE = 'en';

function LocalizedApp() {
  return (
    <Routes>
      {/* é»˜è®¤è¯­è¨€è·¯ç”±ï¼ˆä¸å¸¦è¯­è¨€å‰ç¼€ï¼‰ */}
      <Route path="/*" element={<LocalizedRoutes locale={DEFAULT_LOCALE} />} />
      
      {/* å¸¦è¯­è¨€å‰ç¼€çš„è·¯ç”± */}
      {SUPPORTED_LOCALES.map(locale => (
        <Route
          key={locale}
          path={`/${locale}/*`}
          element={<LocalizedRoutes locale={locale} />}
        />
      ))}
    </Routes>
  );
}

function LocalizedRoutes({ locale }) {
  const { t } = useTranslation(locale);

  return (
    <LocaleContext.Provider value={locale}>
      <Routes>
        <Route path="/" element={<LocalizedLayout />}>
          <Route index element={<Home />} />
          
          {/* äº§å“è·¯ç”± */}
          <Route path="products" element={<ProductsLayout />}>
            <Route index element={<ProductsList />} />
            <Route path="category/:category" element={<CategoryProducts />} />
            <Route path=":productId" element={<ProductDetail />}>
              <Route index element={<ProductOverview />} />
              <Route path="reviews" element={<ProductReviews />} />
              <Route path="specifications" element={<ProductSpecs />} />
            </Route>
          </Route>
          
          {/* ç”¨æˆ·ç›¸å…³è·¯ç”± */}
          <Route path="account" element={<AccountLayout />}>
            <Route index element={<AccountDashboard />} />
            <Route path="profile" element={<Profile />} />
            <Route path="orders" element={<Orders />} />
            <Route path="wishlist" element={<Wishlist />} />
          </Route>
          
          {/* æ”¯æŒé¡µé¢ */}
          <Route path="support" element={<SupportLayout />}>
            <Route index element={<SupportHome />} />
            <Route path="faq" element={<FAQ />} />
            <Route path="contact" element={<Contact />} />
            <Route path="tickets" element={<SupportTickets />} />
            <Route path="tickets/:ticketId" element={<TicketDetail />} />
          </Route>
        </Route>
      </Routes>
    </LocaleContext.Provider>
  );
}

function LocalizedLayout() {
  const locale = useContext(LocaleContext);
  const location = useLocation();

  // è¯­è¨€åˆ‡æ¢å™¨
  const switchLanguage = (newLocale) => {
    const currentPath = location.pathname;
    
    // ç§»é™¤å½“å‰è¯­è¨€å‰ç¼€
    const pathWithoutLocale = currentPath.startsWith(`/${locale}`)
      ? currentPath.slice(`/${locale}`.length)
      : currentPath;
    
    // æ·»åŠ æ–°è¯­è¨€å‰ç¼€
    const newPath = newLocale === DEFAULT_LOCALE
      ? pathWithoutLocale || '/'
      : `/${newLocale}${pathWithoutLocale}`;
    
    navigate(newPath + location.search);
  };

  return (
    <div className="localized-layout" data-locale={locale}>
      <header className="layout-header">
        <nav className="main-nav">
          <Link to={locale === DEFAULT_LOCALE ? '/' : `/${locale}`}>
            Home
          </Link>
          <Link to={locale === DEFAULT_LOCALE ? '/products' : `/${locale}/products`}>
            Products
          </Link>
          <Link to={locale === DEFAULT_LOCALE ? '/account' : `/${locale}/account`}>
            Account
          </Link>
        </nav>

        <div className="language-switcher">
          <select value={locale} onChange={(e) => switchLanguage(e.target.value)}>
            <option value="en">English</option>
            <option value="zh">ä¸­æ–‡</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="ko">í•œêµ­ì–´</option>
          </select>
        </div>
      </header>

      <main className="layout-main">
        <Outlet />
      </main>
    </div>
  );
}

// æœ¬åœ°åŒ–çš„é“¾æ¥ç»„ä»¶
function LocalizedLink({ to, ...props }) {
  const locale = useContext(LocaleContext);
  
  const localizedTo = useMemo(() => {
    if (locale === DEFAULT_LOCALE) {
      return to;
    }
    
    // ç¡®ä¿ä¸é‡å¤æ·»åŠ è¯­è¨€å‰ç¼€
    if (to.startsWith(`/${locale}`)) {
      return to;
    }
    
    return `/${locale}${to}`;
  }, [to, locale]);

  return <Link to={localizedTo} {...props} />;
}
```

## æœ€ä½³å®è·µæ€»ç»“

### 1. å‚æ•°å¤„ç†

```jsx
// å‚æ•°å¤„ç†æœ€ä½³å®è·µ
const parameterBestPractices = {
  // 1. ç±»å‹è½¬æ¢
  typeConversion: {
    good: `
      const { id } = useParams();
      const numericId = parseInt(id, 10);
      
      if (isNaN(numericId)) {
        navigate('/404', { replace: true });
        return;
      }
    `,
    explanation: 'å§‹ç»ˆéªŒè¯å’Œè½¬æ¢å‚æ•°ç±»å‹'
  },

  // 2. å‚æ•°éªŒè¯
  validation: {
    good: `
      const { slug } = useParams();
      
      if (!/^[a-z0-9-]+$/.test(slug)) {
        navigate('/404', { replace: true });
        return;
      }
    `,
    explanation: 'éªŒè¯å‚æ•°æ ¼å¼é˜²æ­¢æ³¨å…¥æ”»å‡»'
  },

  // 3. é»˜è®¤å€¼å¤„ç†
  defaults: {
    good: `
      const page = parseInt(searchParams.get('page')) || 1;
      const limit = parseInt(searchParams.get('limit')) || 10;
    `,
    explanation: 'ä¸ºå‚æ•°æä¾›åˆç†çš„é»˜è®¤å€¼'
  },

  // 4. é”™è¯¯å¤„ç†
  errorHandling: {
    good: `
      useEffect(() => {
        fetchUser(userId)
          .then(setUser)
          .catch(() => navigate('/users', { replace: true }));
      }, [userId]);
    `,
    explanation: 'å‚æ•°æ— æ•ˆæ—¶ä¼˜é›…åœ°å¤„ç†é”™è¯¯'
  }
};
```

### 2. æ€§èƒ½ä¼˜åŒ–

```jsx
// å‚æ•°å˜åŒ–ä¼˜åŒ–
function OptimizedParamsComponent() {
  const { id } = useParams();
  const [searchParams] = useSearchParams();
  
  // ä½¿ç”¨useMemoé¿å…ä¸å¿…è¦çš„é‡æ–°è®¡ç®—
  const filters = useMemo(() => {
    return {
      category: searchParams.get('category'),
      minPrice: parseFloat(searchParams.get('minPrice')) || 0,
      maxPrice: parseFloat(searchParams.get('maxPrice')) || Infinity
    };
  }, [searchParams]);

  // é˜²æŠ–çš„å‚æ•°å¤„ç†
  const debouncedFilters = useDebounce(filters, 300);

  useEffect(() => {
    fetchData(id, debouncedFilters).then(setData);
  }, [id, debouncedFilters]);

  return (
    <div>
      {/* ç»„ä»¶å†…å®¹ */}
    </div>
  );
}

// é˜²æŠ–Hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

## æ€»ç»“

åŠ¨æ€è·¯ç”±å’Œå‚æ•°è·å–æ˜¯æ„å»ºç°ä»£Webåº”ç”¨çš„åŸºç¡€ï¼š

1. **è·¯å¾„å‚æ•°**ï¼šé€šè¿‡useParamsè·å–URLä¸­çš„åŠ¨æ€éƒ¨åˆ†
2. **æŸ¥è¯¢å‚æ•°**ï¼šé€šè¿‡useSearchParamsç®¡ç†URLæŸ¥è¯¢å­—ç¬¦ä¸²
3. **å‚æ•°éªŒè¯**ï¼šç¡®ä¿å‚æ•°æ ¼å¼æ­£ç¡®å’Œç±»å‹å®‰å…¨
4. **çŠ¶æ€åŒæ­¥**ï¼šå°†URLå‚æ•°ä¸ç»„ä»¶çŠ¶æ€åŒæ­¥
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šåˆç†ä½¿ç”¨ç¼“å­˜å’Œé˜²æŠ–
6. **é”™è¯¯å¤„ç†**ï¼šä¼˜é›…å¤„ç†æ— æ•ˆå‚æ•°

æŒæ¡è¿™äº›æŠ€æœ¯å¯ä»¥æ„å»ºå‡ºç”¨æˆ·å‹å¥½ã€SEOå‹å¥½çš„åŠ¨æ€è·¯ç”±ç³»ç»Ÿã€‚
