# ç¦»çº¿æ”¯æŒ

## æ¦‚è¿°

ç¦»çº¿æ”¯æŒæ˜¯ç°ä»£Webåº”ç”¨çš„é‡è¦ç‰¹æ€§,èƒ½å¤Ÿåœ¨ç½‘ç»œä¸ç¨³å®šæˆ–ç¦»çº¿çŠ¶æ€ä¸‹æä¾›æ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚TanStack Queryé€šè¿‡æ™ºèƒ½ç¼“å­˜ã€ç½‘ç»œçŠ¶æ€æ£€æµ‹å’ŒæŒä¹…åŒ–å­˜å‚¨,æä¾›äº†å¼ºå¤§çš„ç¦»çº¿æ”¯æŒèƒ½åŠ›ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»å¦‚ä½•åœ¨Reactåº”ç”¨ä¸­å®ç°ç¦»çº¿åŠŸèƒ½ã€‚

## ç½‘ç»œçŠ¶æ€æ£€æµ‹

### åŸºç¡€ç½‘ç»œæ£€æµ‹

```jsx
import { onlineManager } from '@tanstack/react-query';

function NetworkStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    const unsubscribe = onlineManager.subscribe((online) => {
      setIsOnline(online);
    });
    
    return unsubscribe;
  }, []);
  
  return (
    <div className={`network-status ${isOnline ? 'online' : 'offline'}`}>
      {isOnline ? (
        <>
          <span className="icon">âœ“</span> Online
        </>
      ) : (
        <>
          <span className="icon">âœ—</span> Offline
        </>
      )}
    </div>
  );
}
```

### è‡ªå®šä¹‰ç½‘ç»œæ£€æµ‹

```jsx
import { onlineManager } from '@tanstack/react-query';

// è‡ªå®šä¹‰ç½‘ç»œæ£€æµ‹é€»è¾‘
onlineManager.setEventListener((setOnline) => {
  return window.addEventListener('online', () => {
    // éªŒè¯ç½‘ç»œçœŸæ­£å¯ç”¨
    fetch('https://www.google.com/generate_204', {
      mode: 'no-cors',
    })
      .then(() => setOnline(true))
      .catch(() => setOnline(false));
  });
});

// æˆ–ä½¿ç”¨æ›´å¤æ‚çš„æ£€æµ‹
function setupNetworkDetection() {
  onlineManager.setEventListener((setOnline) => {
    const checkNetwork = async () => {
      try {
        const response = await fetch('/api/health');
        setOnline(response.ok);
      } catch {
        setOnline(false);
      }
    };
    
    window.addEventListener('online', checkNetwork);
    window.addEventListener('offline', () => setOnline(false));
    
    // å®šæœŸæ£€æŸ¥
    const interval = setInterval(checkNetwork, 30000);
    
    return () => {
      window.removeEventListener('online', checkNetwork);
      window.removeEventListener('offline', () => setOnline(false));
      clearInterval(interval);
    };
  });
}
```

## ç¦»çº¿æŸ¥è¯¢é…ç½®

### ç½‘ç»œæ¨¡å¼

```jsx
function OfflineQueries() {
  // 1. onlineæ¨¡å¼(é»˜è®¤): åªåœ¨åœ¨çº¿æ—¶è·å–
  const { data: onlineData } = useQuery({
    queryKey: ['online-data'],
    queryFn: fetchData,
    networkMode: 'online',
  });
  
  // 2. alwaysæ¨¡å¼: æ— è®ºåœ¨çº¿ç¦»çº¿éƒ½å°è¯•è·å–
  const { data: alwaysData } = useQuery({
    queryKey: ['always-data'],
    queryFn: fetchData,
    networkMode: 'always',
  });
  
  // 3. offlineFirstæ¨¡å¼: ä¼˜å…ˆä½¿ç”¨ç¼“å­˜,ç¦»çº¿æ—¶ä¸è·å–
  const { data: offlineFirstData } = useQuery({
    queryKey: ['offline-first-data'],
    queryFn: fetchData,
    networkMode: 'offlineFirst',
  });
  
  return (
    <div>
      <div>Online Data: {JSON.stringify(onlineData)}</div>
      <div>Always Data: {JSON.stringify(alwaysData)}</div>
      <div>Offline First: {JSON.stringify(offlineFirstData)}</div>
    </div>
  );
}
```

### ç¦»çº¿æ—¶ä½¿ç”¨ç¼“å­˜

```jsx
function OfflineCaching() {
  const { data, isLoading, error, isStale } = useQuery({
    queryKey: ['user-data'],
    queryFn: fetchUserData,
    
    // ç¼“å­˜é…ç½®
    staleTime: Infinity,        // æ°¸ä¸è¿‡æœŸ
    cacheTime: Infinity,        // æ°¸ä¸æ¸…é™¤
    
    // ç½‘ç»œé…ç½®
    networkMode: 'offlineFirst', // ä¼˜å…ˆä½¿ç”¨ç¼“å­˜
    
    // ç¦»çº¿æ—¶ä¸é‡æ–°è·å–
    refetchOnWindowFocus: navigator.onLine,
    refetchOnReconnect: true,
    refetchOnMount: navigator.onLine,
  });
  
  return (
    <div>
      {!navigator.onLine && isStale && (
        <div className="warning">
          Showing cached data (offline)
        </div>
      )}
      
      {isLoading && <div>Loading...</div>}
      {error && <div>Error: {error.message}</div>}
      {data && <div>{JSON.stringify(data)}</div>}
    </div>
  );
}
```

## ç¦»çº¿Mutation

### æš‚åœMutation

```jsx
import { focusManager } from '@tanstack/react-query';

function OfflineMutation() {
  const queryClient = useQueryClient();
  
  const { mutate, isPaused } = useMutation({
    mutationFn: updateData,
    networkMode: 'offlineFirst',
    
    // Mutationä¼šåœ¨ç¦»çº¿æ—¶æš‚åœ
    onMutate: async (newData) => {
      if (!navigator.onLine) {
        toast.info('Changes will be synced when online');
      }
      
      // ä¹è§‚æ›´æ–°
      await queryClient.cancelQueries({ queryKey: ['data'] });
      const previousData = queryClient.getQueryData(['data']);
      
      queryClient.setQueryData(['data'], (old) => ({
        ...old,
        ...newData,
      }));
      
      return { previousData };
    },
    
    onError: (err, newData, context) => {
      queryClient.setQueryData(['data'], context.previousData);
    },
    
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['data'] });
    },
  });
  
  return (
    <div>
      <button onClick={() => mutate({ value: 'new' })}>
        Update
      </button>
      {isPaused && (
        <div className="paused">
          Update paused (offline)
        </div>
      )}
    </div>
  );
}
```

### Mutationé˜Ÿåˆ—

```jsx
function MutationQueue() {
  const queryClient = useQueryClient();
  const [pendingMutations, setPendingMutations] = useState([]);
  
  useEffect(() => {
    const mutationCache = queryClient.getMutationCache();
    
    const unsubscribe = mutationCache.subscribe((event) => {
      // è·å–æ‰€æœ‰pendingçš„mutations
      const pending = mutationCache.getAll().filter(
        m => m.state.isPaused
      );
      
      setPendingMutations(pending);
    });
    
    return unsubscribe;
  }, [queryClient]);
  
  useEffect(() => {
    const handleOnline = () => {
      // ç½‘ç»œæ¢å¤æ—¶,æš‚åœçš„mutationsä¼šè‡ªåŠ¨æ¢å¤
      toast.success('Syncing pending changes...');
    };
    
    window.addEventListener('online', handleOnline);
    return () => window.removeEventListener('online', handleOnline);
  }, []);
  
  return (
    <div>
      {pendingMutations.length > 0 && (
        <div className="pending-mutations">
          {pendingMutations.length} changes pending sync
        </div>
      )}
    </div>
  );
}
```

## æ•°æ®æŒä¹…åŒ–

### LocalStorageæŒä¹…åŒ–

```jsx
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';

function setupPersistence() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        cacheTime: 1000 * 60 * 60 * 24, // 24å°æ—¶
        networkMode: 'offlineFirst',
      },
    },
  });
  
  const persister = createSyncStoragePersister({
    storage: window.localStorage,
    key: 'REACT_QUERY_OFFLINE_CACHE',
  });
  
  persistQueryClient({
    queryClient,
    persister,
    maxAge: 1000 * 60 * 60 * 24, // 24å°æ—¶
    dehydrateOptions: {
      shouldDehydrateQuery: (query) => {
        // åªæŒä¹…åŒ–ç‰¹å®šæŸ¥è¯¢
        const queryKey = query.queryKey[0];
        return ['user', 'settings', 'posts'].includes(queryKey);
      },
    },
  });
  
  return queryClient;
}

function App() {
  const queryClient = useMemo(() => setupPersistence(), []);
  
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
```

### IndexedDBæŒä¹…åŒ–

```jsx
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import { get, set, del } from 'idb-keyval';

function setupIndexedDBPersistence() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        cacheTime: 1000 * 60 * 60 * 24 * 7, // 7å¤©
      },
    },
  });
  
  const persister = createAsyncStoragePersister({
    storage: {
      getItem: async (key) => await get(key),
      setItem: async (key, value) => await set(key, value),
      removeItem: async (key) => await del(key),
    },
  });
  
  persistQueryClient({
    queryClient,
    persister,
    maxAge: 1000 * 60 * 60 * 24 * 7,
  });
  
  return queryClient;
}
```

### ç‰ˆæœ¬æ§åˆ¶

```jsx
function setupVersionedPersistence() {
  const APP_VERSION = '1.0.0';
  
  const queryClient = new QueryClient();
  
  const persister = createSyncStoragePersister({
    storage: window.localStorage,
    key: `APP_CACHE_${APP_VERSION}`,
  });
  
  persistQueryClient({
    queryClient,
    persister,
    buster: APP_VERSION, // ç‰ˆæœ¬å˜åŒ–æ—¶æ¸…é™¤ç¼“å­˜
    
    dehydrateOptions: {
      shouldDehydrateMutation: (mutation) => {
        // ä¸æŒä¹…åŒ–mutations
        return false;
      },
    },
  });
  
  // æ¸…ç†æ—§ç‰ˆæœ¬ç¼“å­˜
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith('APP_CACHE_') && key !== `APP_CACHE_${APP_VERSION}`) {
      localStorage.removeItem(key);
    }
  });
  
  return queryClient;
}
```

## Service Workeré›†æˆ

### æ³¨å†ŒService Worker

```jsx
// sw.js
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('api-cache-v1').then((cache) => {
      return cache.addAll([
        '/api/config',
        '/api/static-data',
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  // ç¼“å­˜ä¼˜å…ˆç­–ç•¥
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      caches.match(event.request).then((response) => {
        if (response) {
          // åå°æ›´æ–°ç¼“å­˜
          fetch(event.request).then((networkResponse) => {
            caches.open('api-cache-v1').then((cache) => {
              cache.put(event.request, networkResponse);
            });
          });
          
          return response;
        }
        
        return fetch(event.request).then((networkResponse) => {
          return caches.open('api-cache-v1').then((cache) => {
            cache.put(event.request, networkResponse.clone());
            return networkResponse;
          });
        });
      })
    );
  }
});

// Reactç»„ä»¶
function AppWithServiceWorker() {
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js');
    }
  }, []);
  
  return <App />;
}
```

### åå°åŒæ­¥

```jsx
// sw.js
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-mutations') {
    event.waitUntil(syncMutations());
  }
});

async function syncMutations() {
  const mutations = await getStoredMutations();
  
  for (const mutation of mutations) {
    try {
      await fetch(mutation.url, mutation.options);
      await removeMutation(mutation.id);
    } catch (error) {
      console.error('Failed to sync mutation:', error);
    }
  }
}

// Reactç»„ä»¶
function OfflineSync() {
  const { mutate } = useMutation({
    mutationFn: updateData,
    
    onError: async (error, variables) => {
      if (!navigator.onLine) {
        // å­˜å‚¨mutationä¾›åå°åŒæ­¥
        await storeMutation({
          id: Date.now(),
          url: '/api/data',
          options: {
            method: 'POST',
            body: JSON.stringify(variables),
          },
        });
        
        // æ³¨å†Œåå°åŒæ­¥
        if ('serviceWorker' in navigator && 'sync' in registration) {
          const registration = await navigator.serviceWorker.ready;
          await registration.sync.register('sync-mutations');
        }
      }
    },
  });
  
  return <UpdateForm onSubmit={mutate} />;
}
```

## ç¦»çº¿UIæ¨¡å¼

### ç¦»çº¿æŒ‡ç¤ºå™¨

```jsx
function OfflineIndicator() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [showOfflineBanner, setShowOfflineBanner] = useState(false);
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      setShowOfflineBanner(false);
      toast.success('Back online');
    };
    
    const handleOffline = () => {
      setIsOnline(false);
      setShowOfflineBanner(true);
      toast.warning('You are offline');
    };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  if (!showOfflineBanner) return null;
  
  return (
    <div className="offline-banner">
      <span className="icon">âš ï¸</span>
      You're offline. Some features may be limited.
      <button onClick={() => setShowOfflineBanner(false)}>âœ•</button>
    </div>
  );
}
```

### æ•°æ®æ–°é²œåº¦æŒ‡ç¤º

```jsx
function DataFreshnessIndicator() {
  const { data, dataUpdatedAt } = useQuery({
    queryKey: ['data'],
    queryFn: fetchData,
    networkMode: 'offlineFirst',
  });
  
  const [timeAgo, setTimeAgo] = useState('');
  
  useEffect(() => {
    const updateTimeAgo = () => {
      if (!dataUpdatedAt) return;
      
      const seconds = Math.floor((Date.now() - dataUpdatedAt) / 1000);
      
      if (seconds < 60) {
        setTimeAgo('just now');
      } else if (seconds < 3600) {
        setTimeAgo(`${Math.floor(seconds / 60)} minutes ago`);
      } else {
        setTimeAgo(`${Math.floor(seconds / 3600)} hours ago`);
      }
    };
    
    updateTimeAgo();
    const interval = setInterval(updateTimeAgo, 10000);
    
    return () => clearInterval(interval);
  }, [dataUpdatedAt]);
  
  return (
    <div className="data-freshness">
      <span>Last updated: {timeAgo}</span>
      {!navigator.onLine && (
        <span className="offline-badge">Offline</span>
      )}
    </div>
  );
}
```

### ç¦»çº¿å¯ç”¨åŠŸèƒ½é™åˆ¶

```jsx
function FeatureGating() {
  const isOnline = navigator.onLine;
  
  const { mutate: createPost, isPaused } = useMutation({
    mutationFn: createNewPost,
    networkMode: 'online', // åªåœ¨åœ¨çº¿æ—¶å¯ç”¨
  });
  
  return (
    <div>
      <button
        onClick={() => createPost({ title: 'New Post' })}
        disabled={!isOnline}
        title={isOnline ? '' : 'This feature requires internet connection'}
      >
        Create Post {!isOnline && '(Offline)'}
      </button>
      
      {isPaused && (
        <div className="info">
          Your post will be created when you're back online
        </div>
      )}
    </div>
  );
}
```

## å†²çªè§£å†³

### æ—¶é—´æˆ³å†²çªæ£€æµ‹

```jsx
function ConflictResolution() {
  const { data, mutate } = useMutation({
    mutationFn: async (updates) => {
      const response = await fetch('/api/data', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...updates,
          lastModified: data.lastModified,
        }),
      });
      
      if (response.status === 409) {
        // å†²çª
        const serverData = await response.json();
        throw new ConflictError(serverData);
      }
      
      return response.json();
    },
    
    onError: (error) => {
      if (error instanceof ConflictError) {
        // æ˜¾ç¤ºå†²çªè§£å†³UI
        showConflictDialog(error.serverData);
      }
    },
  });
  
  return <UpdateForm onSubmit={mutate} />;
}

class ConflictError extends Error {
  constructor(serverData) {
    super('Conflict detected');
    this.serverData = serverData;
  }
}
```

### è‡ªåŠ¨åˆå¹¶ç­–ç•¥

```jsx
function AutoMerge() {
  const queryClient = useQueryClient();
  
  const { mutate } = useMutation({
    mutationFn: updateData,
    
    onMutate: async (newData) => {
      const previousData = queryClient.getQueryData(['data']);
      
      // ä¹è§‚æ›´æ–°
      queryClient.setQueryData(['data'], (old) => ({
        ...old,
        ...newData,
        _version: (old._version || 0) + 1,
      }));
      
      return { previousData };
    },
    
    onSuccess: (serverData, variables, context) => {
      const localData = queryClient.getQueryData(['data']);
      
      // æ£€æŸ¥ç‰ˆæœ¬å†²çª
      if (localData._version > serverData._version) {
        // æœ¬åœ°ç‰ˆæœ¬æ›´æ–°,åˆå¹¶å˜æ›´
        queryClient.setQueryData(['data'], {
          ...serverData,
          ...variables,
          _version: localData._version,
        });
      } else {
        // ä½¿ç”¨æœåŠ¡å™¨ç‰ˆæœ¬
        queryClient.setQueryData(['data'], serverData);
      }
    },
  });
  
  return <UpdateForm onSubmit={mutate} />;
}
```

## æ€»ç»“

ç¦»çº¿æ”¯æŒæ ¸å¿ƒè¦ç‚¹ï¼š

1. **ç½‘ç»œæ£€æµ‹**ï¼šonlineManagerã€è‡ªå®šä¹‰æ£€æµ‹
2. **ç¦»çº¿æŸ¥è¯¢**ï¼šnetworkModeé…ç½®ã€ç¼“å­˜ç­–ç•¥
3. **ç¦»çº¿Mutation**ï¼šæš‚åœé˜Ÿåˆ—ã€è‡ªåŠ¨æ¢å¤
4. **æ•°æ®æŒä¹…åŒ–**ï¼šLocalStorageã€IndexedDB
5. **Service Worker**ï¼šåå°åŒæ­¥ã€ç¼“å­˜ç­–ç•¥
6. **ç¦»çº¿UI**ï¼šæŒ‡ç¤ºå™¨ã€æ–°é²œåº¦ã€åŠŸèƒ½é™åˆ¶
7. **å†²çªè§£å†³**ï¼šæ—¶é—´æˆ³æ£€æµ‹ã€è‡ªåŠ¨åˆå¹¶

åˆç†å®ç°ç¦»çº¿æ”¯æŒå¯ä»¥æ˜¾è‘—æå‡åº”ç”¨åœ¨å¼±ç½‘ç¯å¢ƒä¸‹çš„å¯ç”¨æ€§ã€‚

## ç¬¬å››éƒ¨åˆ†ï¼šé«˜çº§ç¦»çº¿æ”¯æŒç­–ç•¥

### 4.1 Service Workeré›†æˆ

```jsx
// 1. Service Workeræ³¨å†Œ
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js')
        .then(registration => {
          console.log('SW registered:', registration);
        })
        .catch(error => {
          console.log('SW registration failed:', error);
        });
    });
  }
}

// 2. Service Workeræ–‡ä»¶ (sw.js)
const CACHE_NAME = 'react-app-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        if (response) {
          return response;
        }
        return fetch(event.request);
      })
  );
});

// 3. åå°åŒæ­¥
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-mutations') {
    event.waitUntil(syncOfflineMutations());
  }
});

async function syncOfflineMutations() {
  const mutations = await getOfflineMutations();
  
  for (const mutation of mutations) {
    try {
      await fetch(mutation.url, {
        method: mutation.method,
        headers: mutation.headers,
        body: JSON.stringify(mutation.data)
      });
      await removeOfflineMutation(mutation.id);
    } catch (error) {
      console.error('Sync failed:', error);
    }
  }
}

// 4. Reactä¸­ä½¿ç”¨Service Worker
function useServiceWorker() {
  const [updateAvailable, setUpdateAvailable] = useState(false);

  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then(registration => {
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              setUpdateAvailable(true);
            }
          });
        });
      });
    }
  }, []);

  const updateApp = () => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then(registration => {
        registration.waiting?.postMessage({ type: 'SKIP_WAITING' });
        window.location.reload();
      });
    }
  };

  return { updateAvailable, updateApp };
}
```

### 4.2 IndexedDBæŒä¹…åŒ–

```jsx
// 1. IndexedDBåŒ…è£…å™¨
class IndexedDBStore {
  constructor(dbName, storeName) {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'id' });
        }
      };
    });
  }

  async get(id) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(id);

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async put(data) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put(data);

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async delete(id) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(id);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getAll() {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

// 2. ä¸TanStack Queryé›†æˆ
const idbStore = new IndexedDBStore('react-cache', 'queries');

function createIDBPersister() {
  return {
    persistClient: async (client) => {
      const queries = client.getQueryCache().getAll();
      const serialized = queries.map(query => ({
        id: JSON.stringify(query.queryKey),
        queryKey: query.queryKey,
        state: query.state,
        timestamp: Date.now()
      }));

      for (const query of serialized) {
        await idbStore.put(query);
      }
    },
    restoreClient: async () => {
      const queries = await idbStore.getAll();
      return {
        clientState: {
          queries: queries.map(q => ({
            queryKey: q.queryKey,
            queryHash: JSON.stringify(q.queryKey),
            state: q.state
          }))
        }
      };
    },
    removeClient: async () => {
      const queries = await idbStore.getAll();
      for (const query of queries) {
        await idbStore.delete(query.id);
      }
    }
  };
}

// 3. ä½¿ç”¨æŒä¹…åŒ–
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client';

function App() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        gcTime: 1000 * 60 * 60 * 24 // 24 hours
      }
    }
  });

  const persister = createIDBPersister();

  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{ persister }}
    >
      <AppContent />
    </PersistQueryClientProvider>
  );
}
```

### 4.3 ç¦»çº¿ä¼˜å…ˆæ¶æ„

```jsx
// 1. ç¦»çº¿ä¼˜å…ˆæŸ¥è¯¢ç­–ç•¥
function useOfflineFirstQuery(queryKey, queryFn) {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return useQuery({
    queryKey,
    queryFn,
    // ç¦»çº¿æ—¶åªä½¿ç”¨ç¼“å­˜
    networkMode: isOnline ? 'online' : 'offlineFirst',
    // ç¼“å­˜æ—¶é—´è®¾ç½®å¾ˆé•¿
    staleTime: 1000 * 60 * 60 * 24, // 24å°æ—¶
    gcTime: 1000 * 60 * 60 * 24 * 7, // 7å¤©
    // ç¦»çº¿æ—¶ä¸é‡æ–°è·å–
    refetchOnMount: isOnline,
    refetchOnWindowFocus: isOnline,
    refetchOnReconnect: true
  });
}

// 2. ç¦»çº¿Mutationé˜Ÿåˆ—
class OfflineMutationManager {
  constructor() {
    this.queue = this.loadQueue();
    this.isProcessing = false;
  }

  loadQueue() {
    const saved = localStorage.getItem('offline-mutation-queue');
    return saved ? JSON.parse(saved) : [];
  }

  saveQueue() {
    localStorage.setItem('offline-mutation-queue', JSON.stringify(this.queue));
  }

  enqueue(mutation) {
    this.queue.push({
      id: Date.now(),
      ...mutation,
      timestamp: new Date().toISOString(),
      retryCount: 0
    });
    this.saveQueue();
  }

  dequeue(id) {
    this.queue = this.queue.filter(m => m.id !== id);
    this.saveQueue();
  }

  async processQueue() {
    if (this.isProcessing || !navigator.onLine) return;
    
    this.isProcessing = true;

    while (this.queue.length > 0 && navigator.onLine) {
      const mutation = this.queue[0];

      try {
        await fetch(mutation.url, {
          method: mutation.method,
          headers: mutation.headers,
          body: JSON.stringify(mutation.data)
        });

        this.dequeue(mutation.id);
      } catch (error) {
        mutation.retryCount++;
        
        if (mutation.retryCount >= 3) {
          this.dequeue(mutation.id);
          console.error('Max retries reached for mutation:', mutation);
        } else {
          this.saveQueue();
        }
        
        break;
      }
    }

    this.isProcessing = false;
  }

  getQueueStatus() {
    return {
      pending: this.queue.length,
      items: this.queue.map(m => ({
        id: m.id,
        type: m.type,
        retryCount: m.retryCount,
        timestamp: m.timestamp
      }))
    };
  }
}

const mutationManager = new OfflineMutationManager();

// 3. ä½¿ç”¨ç¦»çº¿Mutation
function useOfflineMutation(mutationFn, options = {}) {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const queryClient = useQueryClient();

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      mutationManager.processQueue();
    };
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return useMutation({
    mutationFn: async (variables) => {
      if (!isOnline) {
        // ç¦»çº¿æ—¶åŠ å…¥é˜Ÿåˆ—
        mutationManager.enqueue({
          type: options.type || 'unknown',
          url: options.url,
          method: options.method || 'POST',
          headers: options.headers || { 'Content-Type': 'application/json' },
          data: variables
        });

        // æ‰§è¡Œä¹è§‚æ›´æ–°
        if (options.onMutate) {
          await options.onMutate(variables);
        }

        return { offline: true, queued: true };
      }

      return mutationFn(variables);
    },
    ...options
  });
}
```

### 4.4 æ•°æ®åŒæ­¥ç­–ç•¥

```jsx
// 1. å·®å¼‚åŒæ­¥
class DiffSync {
  constructor() {
    this.localChanges = new Map();
    this.serverVersion = 0;
  }

  trackChange(key, change) {
    if (!this.localChanges.has(key)) {
      this.localChanges.set(key, []);
    }
    this.localChanges.get(key).push({
      ...change,
      timestamp: Date.now(),
      version: this.serverVersion + this.localChanges.get(key).length + 1
    });
  }

  async sync() {
    if (!navigator.onLine || this.localChanges.size === 0) return;

    const changes = Array.from(this.localChanges.entries()).map(([key, changes]) => ({
      key,
      changes
    }));

    try {
      const response = await fetch('/api/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          clientVersion: this.serverVersion,
          changes
        })
      });

      const result = await response.json();

      // åº”ç”¨æœåŠ¡å™¨å˜æ›´
      if (result.serverChanges) {
        this.applyServerChanges(result.serverChanges);
      }

      // æ¸…é™¤å·²åŒæ­¥çš„æœ¬åœ°å˜æ›´
      this.localChanges.clear();
      this.serverVersion = result.serverVersion;

      return result;
    } catch (error) {
      console.error('Sync failed:', error);
      throw error;
    }
  }

  applyServerChanges(serverChanges) {
    serverChanges.forEach(change => {
      // åº”ç”¨æœåŠ¡å™¨å˜æ›´åˆ°æœ¬åœ°çŠ¶æ€
      console.log('Applying server change:', change);
    });
  }
}

// 2. å†²çªè§£å†³
class ConflictResolver {
  resolveConflict(local, server) {
    // ä½¿ç”¨æœ€åå†™å…¥æ—¶é—´
    if (local.timestamp > server.timestamp) {
      return local;
    } else if (server.timestamp > local.timestamp) {
      return server;
    }

    // æ—¶é—´æˆ³ç›¸åŒï¼Œå°è¯•åˆå¹¶
    return this.mergeChanges(local, server);
  }

  mergeChanges(local, server) {
    const merged = { ...server };

    Object.keys(local).forEach(key => {
      if (key !== 'timestamp' && key !== 'version') {
        // å¦‚æœæœåŠ¡å™¨æ²¡æœ‰è¿™ä¸ªå­—æ®µï¼Œä½¿ç”¨æœ¬åœ°å€¼
        if (!(key in server)) {
          merged[key] = local[key];
        }
        // å¦‚æœéƒ½æœ‰ï¼Œä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨å€¼ï¼ˆå¯æ ¹æ®ä¸šåŠ¡è°ƒæ•´ï¼‰
      }
    });

    merged.timestamp = Math.max(local.timestamp, server.timestamp);
    return merged;
  }

  resolveArrayConflict(local, server) {
    // æ•°ç»„åˆå¹¶å»é‡
    const merged = [...server];
    
    local.forEach(item => {
      const exists = merged.find(m => m.id === item.id);
      if (!exists) {
        merged.push(item);
      } else if (item.timestamp > exists.timestamp) {
        const index = merged.findIndex(m => m.id === item.id);
        merged[index] = item;
      }
    });

    return merged;
  }
}

// 3. è‡ªåŠ¨åŒæ­¥Hook
function useAutoSync(interval = 30000) {
  const diffSync = useRef(new DiffSync()).current;
  const [syncStatus, setSyncStatus] = useState('idle');
  const [lastSyncTime, setLastSyncTime] = useState(null);

  const performSync = useCallback(async () => {
    if (!navigator.onLine) {
      setSyncStatus('offline');
      return;
    }

    setSyncStatus('syncing');

    try {
      await diffSync.sync();
      setSyncStatus('success');
      setLastSyncTime(new Date());
    } catch (error) {
      setSyncStatus('error');
      console.error('Auto sync failed:', error);
    }
  }, [diffSync]);

  useEffect(() => {
    const syncInterval = setInterval(performSync, interval);

    const handleOnline = () => {
      performSync();
    };

    window.addEventListener('online', handleOnline);

    return () => {
      clearInterval(syncInterval);
      window.removeEventListener('online', handleOnline);
    };
  }, [performSync, interval]);

  return {
    syncStatus,
    lastSyncTime,
    trackChange: diffSync.trackChange.bind(diffSync),
    manualSync: performSync
  };
}
```

### 4.5 ç¦»çº¿UIç»„ä»¶

```jsx
// 1. ç¦»çº¿æŒ‡ç¤ºå™¨
function OfflineIndicator() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const mutationQueue = mutationManager.getQueueStatus();

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  if (isOnline && mutationQueue.pending === 0) return null;

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      padding: '10px',
      background: isOnline ? '#ffa500' : '#f44336',
      color: 'white',
      textAlign: 'center',
      zIndex: 9999
    }}>
      {!isOnline && 'âš ï¸ ç¦»çº¿æ¨¡å¼'}
      {isOnline && mutationQueue.pending > 0 && (
        `ğŸ”„ æ­£åœ¨åŒæ­¥ ${mutationQueue.pending} ä¸ªå¾…å¤„ç†æ›´æ–°...`
      )}
    </div>
  );
}

// 2. æ•°æ®æ–°é²œåº¦æŒ‡ç¤ºå™¨
function DataFreshnessIndicator({ lastUpdate }) {
  const [freshness, setFreshness] = useState('fresh');

  useEffect(() => {
    const checkFreshness = () => {
      const age = Date.now() - lastUpdate;
      
      if (age < 60000) {
        setFreshness('fresh'); // < 1åˆ†é’Ÿ
      } else if (age < 3600000) {
        setFreshness('stale'); // 1åˆ†é’Ÿ - 1å°æ—¶
      } else {
        setFreshness('very-stale'); // > 1å°æ—¶
      }
    };

    const interval = setInterval(checkFreshness, 10000);
    checkFreshness();

    return () => clearInterval(interval);
  }, [lastUpdate]);

  const colors = {
    fresh: '#4caf50',
    stale: '#ffa500',
    'very-stale': '#f44336'
  };

  return (
    <div style={{
      display: 'inline-block',
      width: '10px',
      height: '10px',
      borderRadius: '50%',
      background: colors[freshness],
      marginLeft: '5px'
    }} />
  );
}

// 3. ç¦»çº¿åŠŸèƒ½æç¤º
function OfflineFeatureGuard({ children, fallback }) {
  const [isOnline] = useState(navigator.onLine);

  if (!isOnline && fallback) {
    return fallback;
  }

  return children;
}

// ä½¿ç”¨ç¤ºä¾‹
function MyComponent() {
  return (
    <>
      <OfflineIndicator />
      
      <div>
        æ•°æ®æ›´æ–°æ—¶é—´: {new Date().toLocaleString()}
        <DataFreshnessIndicator lastUpdate={Date.now()} />
      </div>

      <OfflineFeatureGuard
        fallback={<div>æ­¤åŠŸèƒ½éœ€è¦ç½‘ç»œè¿æ¥</div>}
      >
        <OnlineOnlyFeature />
      </OfflineFeatureGuard>
    </>
  );
}
```

## ç¦»çº¿æ”¯æŒæœ€ä½³å®è·µæ€»ç»“

```
1. Service Worker
   âœ… ç¼“å­˜é™æ€èµ„æº
   âœ… åå°åŒæ­¥
   âœ… æ¨é€é€šçŸ¥æ”¯æŒ
   âœ… ç‰ˆæœ¬æ›´æ–°ç®¡ç†

2. æ•°æ®æŒä¹…åŒ–
   âœ… IndexedDBå­˜å‚¨
   âœ… ä¸æŸ¥è¯¢ç¼“å­˜é›†æˆ
   âœ… è‡ªåŠ¨æ¸…ç†ç­–ç•¥

3. ç¦»çº¿ä¼˜å…ˆ
   âœ… ç¦»çº¿ä¼˜å…ˆæŸ¥è¯¢
   âœ… Mutationé˜Ÿåˆ—
   âœ… ä¹è§‚æ›´æ–°

4. æ•°æ®åŒæ­¥
   âœ… å·®å¼‚åŒæ­¥
   âœ… å†²çªè§£å†³
   âœ… è‡ªåŠ¨åŒæ­¥

5. ç”¨æˆ·ä½“éªŒ
   âœ… ç¦»çº¿æŒ‡ç¤ºå™¨
   âœ… æ•°æ®æ–°é²œåº¦
   âœ… åŠŸèƒ½é™çº§
```

å®Œå–„çš„ç¦»çº¿æ”¯æŒæ˜¯ç°ä»£Webåº”ç”¨çš„å¿…å¤‡ç‰¹æ€§ï¼Œèƒ½å¤Ÿæ˜¾è‘—æå‡ç”¨æˆ·ä½“éªŒï¼Œç‰¹åˆ«æ˜¯åœ¨ç½‘ç»œä¸ç¨³å®šçš„ç¯å¢ƒä¸‹ã€‚
