# 生命周期对照表 - React类组件与函数组件完全对照

本文档提供React类组件生命周期方法与函数组件Hooks的完整对照，帮助理解和迁移。

## 1. 生命周期概览

### 1.1 类组件生命周期阶段

```typescript
const lifecyclePhases = {
  挂载阶段: [
    'constructor',
    'static getDerivedStateFromProps',
    'render',
    'componentDidMount'
  ],
  更新阶段: [
    'static getDerivedStateFromProps',
    'shouldComponentUpdate',
    'render',
    'getSnapshotBeforeUpdate',
    'componentDidUpdate'
  ],
  卸载阶段: [
    'componentWillUnmount'
  ],
  错误处理: [
    'static getDerivedStateFromError',
    'componentDidCatch'
  ]
};
```

### 1.2 生命周期流程图

```
挂载流程:
constructor → getDerivedStateFromProps → render → componentDidMount

更新流程:
getDerivedStateFromProps → shouldComponentUpdate → render → 
getSnapshotBeforeUpdate → componentDidUpdate

卸载流程:
componentWillUnmount
```

## 2. 挂载阶段对照

### 2.1 constructor

**类组件**
```tsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    
    // 初始化state
    this.state = {
      count: 0,
      data: null
    };
    
    // 绑定方法
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return <div onClick={this.handleClick}>{this.state.count}</div>;
  }
}
```

**函数组件对应**
```tsx
function Component(props) {
  // useState替代state初始化
  const [count, setCount] = useState(0);
  const [data, setData] = useState(null);
  
  // 不需要bind，直接定义函数
  const handleClick = () => {
    setCount(count + 1);
  };
  
  return <div onClick={handleClick}>{count}</div>;
}
```

**对照说明**
| 类组件 | 函数组件 | 说明 |
|--------|----------|------|
| constructor | useState | 状态初始化 |
| this.state | const [state] | 状态声明 |
| this.setState | setState | 状态更新 |
| bind方法 | 箭头函数 | 方法绑定 |

---

### 2.2 static getDerivedStateFromProps

**类组件**
```tsx
class Component extends React.Component {
  state = { prevUserId: null, user: null };
  
  static getDerivedStateFromProps(props, state) {
    // props变化时派生state
    if (props.userId !== state.prevUserId) {
      return {
        prevUserId: props.userId,
        user: null  // 重置user
      };
    }
    return null;
  }
  
  componentDidMount() {
    if (this.state.user === null) {
      this.fetchUser(this.props.userId);
    }
  }
  
  componentDidUpdate(prevProps, prevState) {
    if (this.state.user === null && prevState.user !== null) {
      this.fetchUser(this.props.userId);
    }
  }
  
  fetchUser(userId) {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(user => this.setState({ user }));
  }
  
  render() {
    return <div>{this.state.user?.name}</div>;
  }
}
```

**函数组件对应**
```tsx
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  // useEffect替代getDerivedStateFromProps + componentDidMount/Update
  useEffect(() => {
    // userId变化时重新获取
    setUser(null);  // 重置user
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);  // userId作为依赖
  
  return <div>{user?.name}</div>;
}

// 或者更简洁的方式
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        if (!cancelled) setUser(data);
      });
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  return <div>{user?.name}</div>;
}
```

**对照说明**
- getDerivedStateFromProps: 用于从props派生state
- 函数组件: 使用useEffect监听props变化
- 更推荐: 直接使用props，避免派生状态

---

### 2.3 componentDidMount

**类组件**
```tsx
class Component extends React.Component {
  componentDidMount() {
    // 数据获取
    fetch('/api/data')
      .then(res => res.json())
      .then(data => this.setState({ data }));
    
    // 订阅
    this.subscription = subscribe(data => {
      this.setState({ data });
    });
    
    // DOM操作
    this.inputRef.current.focus();
    
    // 定时器
    this.timer = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }
  
  componentWillUnmount() {
    // 清理
    this.subscription.unsubscribe();
    clearInterval(this.timer);
  }
  
  render() {
    return <input ref={this.inputRef} />;
  }
}
```

**函数组件对应**
```tsx
function Component() {
  const [data, setData] = useState(null);
  const [time, setTime] = useState(Date.now());
  const inputRef = useRef(null);
  
  // 数据获取
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);  // 空依赖 = componentDidMount
  
  // 订阅
  useEffect(() => {
    const subscription = subscribe(setData);
    
    return () => {
      subscription.unsubscribe();  // cleanup = componentWillUnmount
    };
  }, []);
  
  // DOM操作
  useEffect(() => {
    inputRef.current?.focus();
  }, []);
  
  // 定时器
  useEffect(() => {
    const timer = setInterval(() => {
      setTime(Date.now());
    }, 1000);
    
    return () => clearInterval(timer);
  }, []);
  
  return <input ref={inputRef} />;
}
```

**对照说明**
| 类组件 | 函数组件 | 说明 |
|--------|----------|------|
| componentDidMount | useEffect(() => {}, []) | mount时执行 |
| componentWillUnmount | useEffect cleanup | 卸载时清理 |
| 多个生命周期方法 | 多个useEffect | 按关注点分离 |

---

## 3. 更新阶段对照

### 3.1 shouldComponentUpdate

**类组件**
```tsx
class Component extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // 自定义比较逻辑
    return (
      nextProps.value !== this.props.value ||
      nextState.count !== this.state.count
    );
  }
  
  render() {
    return <div>{this.props.value}</div>;
  }
}

// 或使用PureComponent (浅比较)
class PureComponent extends React.PureComponent {
  render() {
    return <div>{this.props.value}</div>;
  }
}
```

**函数组件对应**
```tsx
// React.memo (浅比较)
const Component = React.memo(function({ value }) {
  return <div>{value}</div>;
});

// React.memo + 自定义比较
const Component = React.memo(
  function({ value, count }) {
    return <div>{value}</div>;
  },
  (prevProps, nextProps) => {
    // 返回true = 跳过渲染，false = 重新渲染
    return (
      prevProps.value === nextProps.value &&
      prevProps.count === nextProps.count
    );
  }
);

// 使用useMemo优化子组件
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  // 只在count变化时重新创建
  const childProps = useMemo(() => ({
    value: count
  }), [count]);
  
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <MemoChild {...childProps} />
    </>
  );
}
```

**对照说明**
| 类组件 | 函数组件 | 说明 |
|--------|----------|------|
| shouldComponentUpdate | React.memo | 优化渲染 |
| PureComponent | React.memo | 浅比较 |
| 自定义比较 | memo第二参数 | 深度控制 |

---

### 3.2 componentDidUpdate

**类组件**
```tsx
class Component extends React.Component {
  componentDidUpdate(prevProps, prevState, snapshot) {
    // props变化时的副作用
    if (this.props.userId !== prevProps.userId) {
      this.fetchUser(this.props.userId);
    }
    
    // state变化时的副作用
    if (this.state.count !== prevState.count) {
      document.title = `Count: ${this.state.count}`;
    }
    
    // 使用snapshot
    if (snapshot !== null) {
      this.listRef.scrollTop = snapshot;
    }
  }
  
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 在DOM更新前获取信息
    if (prevState.list.length < this.state.list.length) {
      return this.listRef.scrollHeight - this.listRef.scrollTop;
    }
    return null;
  }
  
  render() {
    return <div ref={ref => this.listRef = ref}>{/* ... */}</div>;
  }
}
```

**函数组件对应**
```tsx
function Component({ userId }) {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState(null);
  
  // props变化时的副作用
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);  // userId变化时执行
  
  // state变化时的副作用
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);  // count变化时执行
  
  return <div>{user?.name}</div>;
}

// 对于getSnapshotBeforeUpdate，使用useLayoutEffect
function ScrollList({ items }) {
  const listRef = useRef(null);
  const prevItemsLength = useRef(items.length);
  
  useLayoutEffect(() => {
    if (items.length > prevItemsLength.current && listRef.current) {
      const prevScrollHeight = listRef.current.scrollHeight;
      const prevScrollTop = listRef.current.scrollTop;
      
      // DOM更新后同步调整滚动位置
      listRef.current.scrollTop = prevScrollTop + 
        (listRef.current.scrollHeight - prevScrollHeight);
    }
    
    prevItemsLength.current = items.length;
  }, [items]);
  
  return (
    <div ref={listRef}>
      {items.map(item => <div key={item.id}>{item.text}</div>)}
    </div>
  );
}
```

**对照说明**
| 类组件 | 函数组件 | 说明 |
|--------|----------|------|
| componentDidUpdate | useEffect(() => {}, [deps]) | 依赖变化时执行 |
| 比较prevProps | deps数组 | 自动比较 |
| getSnapshotBeforeUpdate | useLayoutEffect | 同步DOM操作 |

---

### 3.3 getSnapshotBeforeUpdate

**类组件**
```tsx
class ChatThread extends React.Component {
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // DOM更新前获取滚动位置
    if (prevProps.messages.length < this.props.messages.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }
  
  componentDidUpdate(prevProps, prevState, snapshot) {
    // 使用snapshot调整滚动
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }
  
  render() {
    return (
      <div ref={this.listRef}>
        {this.props.messages.map(msg => (
          <div key={msg.id}>{msg.text}</div>
        ))}
      </div>
    );
  }
}
```

**函数组件对应**
```tsx
function ChatThread({ messages }) {
  const listRef = useRef(null);
  const prevMessagesLength = useRef(messages.length);
  
  useLayoutEffect(() => {
    const list = listRef.current;
    if (!list) return;
    
    const wasAtBottom = 
      list.scrollHeight - list.scrollTop === list.clientHeight;
    
    if (messages.length > prevMessagesLength.current) {
      if (wasAtBottom) {
        // 如果之前在底部，保持在底部
        list.scrollTop = list.scrollHeight;
      }
    }
    
    prevMessagesLength.current = messages.length;
  }, [messages]);
  
  return (
    <div ref={listRef}>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}
```

---

## 4. 卸载阶段对照

### 4.1 componentWillUnmount

**类组件**
```tsx
class Component extends React.Component {
  componentDidMount() {
    // 设置订阅
    this.subscription = subscribe(this.handleData);
    
    // 设置定时器
    this.timer = setInterval(this.updateTime, 1000);
    
    // 添加事件监听
    window.addEventListener('resize', this.handleResize);
    
    // 建立连接
    this.connection = new WebSocket('ws://...');
  }
  
  componentWillUnmount() {
    // 清理订阅
    this.subscription.unsubscribe();
    
    // 清理定时器
    clearInterval(this.timer);
    
    // 移除事件监听
    window.removeEventListener('resize', this.handleResize);
    
    // 关闭连接
    this.connection.close();
  }
  
  render() {
    return <div />;
  }
}
```

**函数组件对应**
```tsx
function Component() {
  // 订阅
  useEffect(() => {
    const subscription = subscribe(handleData);
    return () => subscription.unsubscribe();
  }, []);
  
  // 定时器
  useEffect(() => {
    const timer = setInterval(updateTime, 1000);
    return () => clearInterval(timer);
  }, []);
  
  // 事件监听
  useEffect(() => {
    const handleResize = () => {/* ... */};
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  // WebSocket连接
  useEffect(() => {
    const connection = new WebSocket('ws://...');
    return () => connection.close();
  }, []);
  
  return <div />;
}

// 或合并到一个useEffect
function Component() {
  useEffect(() => {
    const subscription = subscribe(handleData);
    const timer = setInterval(updateTime, 1000);
    const handleResize = () => {/* ... */};
    window.addEventListener('resize', handleResize);
    const connection = new WebSocket('ws://...');
    
    // 返回清理函数
    return () => {
      subscription.unsubscribe();
      clearInterval(timer);
      window.removeEventListener('resize', handleResize);
      connection.close();
    };
  }, []);
  
  return <div />;
}
```

**对照说明**
- componentWillUnmount: 组件卸载时执行
- useEffect cleanup: 返回的函数在卸载时执行
- 可以有多个useEffect，每个负责一类清理

---

## 5. 错误处理对照

### 5.1 componentDidCatch

**类组件**
```tsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    // 更新state以显示fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // 记录错误到日志服务
    console.error('Error caught:', error, errorInfo);
    logErrorToService(error, errorInfo);
    
    this.setState({
      error,
      errorInfo
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Something went wrong.</h1>
          <details>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo && this.state.errorInfo.componentStack}
          </details>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

**函数组件对应**
```tsx
// ⚠️ 注意: 函数组件目前没有错误边界的直接对应
// 必须使用类组件或第三方库

// 使用react-error-boundary库
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <p>Something went wrong:</p>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, errorInfo) => {
        console.error('Error:', error, errorInfo);
        logErrorToService(error, errorInfo);
      }}
      onReset={() => {
        // 重置应用状态
      }}
    >
      <MyComponent />
    </ErrorBoundary>
  );
}
```

**对照说明**
- 错误边界目前只能用类组件
- getDerivedStateFromError: 渲染fallback UI
- componentDidCatch: 记录错误信息
- 函数组件: 使用第三方库或包裹类组件

---

## 6. 完整对照表

### 6.1 挂载阶段

| 类组件 | 函数组件 | 用途 |
|--------|----------|------|
| constructor | useState | 初始化state |
| getDerivedStateFromProps | useEffect | 派生state |
| render | 函数体 | 返回JSX |
| componentDidMount | useEffect(() => {}, []) | 副作用 |

### 6.2 更新阶段

| 类组件 | 函数组件 | 用途 |
|--------|----------|------|
| getDerivedStateFromProps | useEffect | 派生state |
| shouldComponentUpdate | React.memo | 优化渲染 |
| render | 函数体 | 返回JSX |
| getSnapshotBeforeUpdate | useLayoutEffect | 获取快照 |
| componentDidUpdate | useEffect(() => {}, [deps]) | 副作用 |

### 6.3 卸载阶段

| 类组件 | 函数组件 | 用途 |
|--------|----------|------|
| componentWillUnmount | useEffect cleanup | 清理 |

### 6.4 错误处理

| 类组件 | 函数组件 | 用途 |
|--------|----------|------|
| getDerivedStateFromError | 无直接对应 | 错误state |
| componentDidCatch | 无直接对应 | 错误日志 |

---

## 7. 废弃生命周期

### 7.1 UNSAFE生命周期

**已废弃（React 17+）**
```tsx
// ❌ 不推荐使用
class OldComponent extends React.Component {
  UNSAFE_componentWillMount() { }
  UNSAFE_componentWillReceiveProps(nextProps) { }
  UNSAFE_componentWillUpdate(nextProps, nextState) { }
}
```

**替代方案**
```tsx
// ✅ 使用安全的生命周期
class SafeComponent extends React.Component {
  componentDidMount() { }
  
  static getDerivedStateFromProps(props, state) { }
  
  componentDidUpdate(prevProps, prevState) { }
  
  getSnapshotBeforeUpdate(prevProps, prevState) { }
}

// ✅ 或迁移到函数组件
function SafeFunctionComponent(props) {
  useEffect(() => {
    // componentDidMount + componentDidUpdate
  });
  
  return <div />;
}
```

---

## 8. 迁移指南

### 8.1 从类组件迁移到函数组件

**步骤1: 转换基础结构**
```tsx
// Before: 类组件
class Counter extends React.Component {
  state = { count: 0 };
  
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };
  
  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>+</button>
      </div>
    );
  }
}

// After: 函数组件
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(count + 1);
  };
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

**步骤2: 转换生命周期**
```tsx
// Before
class DataLoader extends React.Component {
  state = { data: null };
  
  componentDidMount() {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => this.setState({ data }));
  }
  
  componentWillUnmount() {
    // 清理
  }
  
  render() {
    return <div>{this.state.data}</div>;
  }
}

// After
function DataLoader() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
    
    return () => {
      // 清理
    };
  }, []);
  
  return <div>{data}</div>;
}
```

**步骤3: 转换refs**
```tsx
// Before
class InputComponent extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  
  focus = () => {
    this.inputRef.current.focus();
  };
  
  render() {
    return <input ref={this.inputRef} />;
  }
}

// After
function InputComponent() {
  const inputRef = useRef(null);
  
  const focus = () => {
    inputRef.current?.focus();
  };
  
  return <input ref={inputRef} />;
}
```

### 8.2 迁移检查清单

```typescript
const migrationChecklist = {
  状态管理: [
    '✅ constructor → useState',
    '✅ this.state → const [state]',
    '✅ this.setState → setState'
  ],
  生命周期: [
    '✅ componentDidMount → useEffect(() => {}, [])',
    '✅ componentDidUpdate → useEffect(() => {}, [deps])',
    '✅ componentWillUnmount → useEffect cleanup',
    '✅ getDerivedStateFromProps → useEffect',
    '✅ shouldComponentUpdate → React.memo'
  ],
  方法: [
    '✅ 类方法 → 函数',
    '✅ bind → 箭头函数',
    '✅ this.props → props参数',
    '✅ this.state → useState'
  ],
  refs: [
    '✅ createRef → useRef',
    '✅ callback refs → useRef + useEffect'
  ],
  Context: [
    '✅ contextType → useContext',
    '✅ Consumer → useContext'
  ]
};
```

---

## 9. 常见模式对照

### 9.1 数据获取

**类组件**
```tsx
class UserProfile extends React.Component {
  state = { user: null, loading: true };
  
  componentDidMount() {
    this.fetchUser(this.props.userId);
  }
  
  componentDidUpdate(prevProps) {
    if (this.props.userId !== prevProps.userId) {
      this.fetchUser(this.props.userId);
    }
  }
  
  fetchUser(userId) {
    this.setState({ loading: true });
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(user => this.setState({ user, loading: false }));
  }
  
  render() {
    if (this.state.loading) return <div>Loading...</div>;
    return <div>{this.state.user.name}</div>;
  }
}
```

**函数组件**
```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    let cancelled = false;
    
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(user => {
        if (!cancelled) {
          setUser(user);
          setLoading(false);
        }
      });
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}
```

### 9.2 订阅模式

**类组件**
```tsx
class Clock extends React.Component {
  state = { time: Date.now() };
  
  componentDidMount() {
    this.timerID = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }
  
  componentWillUnmount() {
    clearInterval(this.timerID);
  }
  
  render() {
    return <div>{new Date(this.state.time).toLocaleTimeString()}</div>;
  }
}
```

**函数组件**
```tsx
function Clock() {
  const [time, setTime] = useState(Date.now());
  
  useEffect(() => {
    const timerID = setInterval(() => {
      setTime(Date.now());
    }, 1000);
    
    return () => clearInterval(timerID);
  }, []);
  
  return <div>{new Date(time).toLocaleTimeString()}</div>;
}
```

### 9.3 表单处理

**类组件**
```tsx
class Form extends React.Component {
  state = { name: '', email: '' };
  
  handleChange = (e) => {
    this.setState({ [e.target.name]: e.target.value });
  };
  
  handleSubmit = (e) => {
    e.preventDefault();
    console.log(this.state);
  };
  
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          name="name"
          value={this.state.name}
          onChange={this.handleChange}
        />
        <input
          name="email"
          value={this.state.email}
          onChange={this.handleChange}
        />
        <button>Submit</button>
      </form>
    );
  }
}
```

**函数组件**
```tsx
function Form() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  
  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
      />
      <input
        name="email"
        value={formData.email}
        onChange={handleChange}
      />
      <button>Submit</button>
    </form>
  );
}
```

---

## 10. 性能优化对照

### 10.1 避免不必要渲染

**类组件**
```tsx
class ExpensiveComponent extends React.PureComponent {
  render() {
    return <div>{this.props.data}</div>;
  }
}

// 或
class ExpensiveComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.data !== this.props.data;
  }
  
  render() {
    return <div>{this.props.data}</div>;
  }
}
```

**函数组件**
```tsx
const ExpensiveComponent = React.memo(function({ data }) {
  return <div>{data}</div>;
});

// 或带自定义比较
const ExpensiveComponent = React.memo(
  function({ data }) {
    return <div>{data}</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.data === nextProps.data;
  }
);
```

### 10.2 缓存计算

**类组件**
```tsx
class DataList extends React.Component {
  getFilteredData() {
    // 每次render都重新计算
    return this.props.data.filter(item => item.active);
  }
  
  render() {
    const filtered = this.getFilteredData();
    return <div>{filtered.length} items</div>;
  }
}
```

**函数组件**
```tsx
function DataList({ data }) {
  // useMemo缓存计算结果
  const filtered = useMemo(() => {
    return data.filter(item => item.active);
  }, [data]);
  
  return <div>{filtered.length} items</div>;
}
```

---

## 11. 总结

生命周期迁移要点:

1. **挂载**: constructor → useState, componentDidMount → useEffect([], )
2. **更新**: componentDidUpdate → useEffect([deps])
3. **卸载**: componentWillUnmount → useEffect cleanup
4. **优化**: shouldComponentUpdate → React.memo
5. **错误**: 错误边界仍需类组件
6. **派生状态**: 避免使用，直接计算或useEffect
7. **refs**: createRef → useRef
8. **Context**: contextType → useContext

函数组件的优势:
- 更简洁的代码
- 更好的逻辑复用（自定义Hooks）
- 更容易测试
- 更好的性能优化
- 更符合React未来方向

建议新项目直接使用函数组件和Hooks。

